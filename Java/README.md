# INDEX_Java

![image](https://github.com/MinwungRo/Personal-study/assets/167000133/b1459b23-15d1-4ff7-9067-56e8ef2b3182)

1. [변수(Variable)](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#1-%EB%B3%80%EC%88%98variable)

2. [연산자(Operator)](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#2-%EC%97%B0%EC%82%B0%EC%9E%90operator)

3. [조건문(Conditional statement)](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#3%EC%A1%B0%EA%B1%B4%EB%AC%B8conditional-statements)

4. [반복문(Loop)](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#4%EB%B0%98%EB%B3%B5%EB%AC%B8loop)

5. [배열(Array)](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#5-%EB%B0%B0%EC%97%B4array)

6. [객체지향 프로그래밍 1](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#6-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1)

7. [객체지향 프로그래밍 2](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#7-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-2)
******************************************************************************************************************************************************************************************

## 1. 변수(Variable)


### 1. 변수(Variable)란?

* 값을 저장할 수 있는 저장 공간

* Memory의 특정 공간을 확보하여 해당 공간에 데이터를 할당할 수 있다

* 변수가 필요하다면 먼저 <b>변수 선언</b>이 선행되어야 한다 (저장 공간 확보)

* 변수 선언 후 <b>초기화(최초 값 부여)</b>가 필요하다, Computer의 Memory는 복수의 대상과 유기적인 관계를 형성하고 있어 <b>특정 값이 할당</b>되어 있다. 따라서 변수를 초기화 하지 않으면 <b>예상치 못한 값이 출력</b>될 수 있다

#### *변수 선언 및 초기화*

```java
변수타입 변수이름; // 변수 선언
변수타입 변수이름 = 값; // 변수 초기화
```

******************************************************************************************************************************************************************************************

#### 1. 2) 변수 Type

* 변수는 값의 형태 및 크기에 따라 해당하는 <b>Type(형식)</b>이 존재한다

* long, double 형의 경우 <b>접미사를 포함</b>하여 값을 입력해야 한다

* 상수(constant)는 변수와 마찬가지로 값을 저장하는 공간이지만, <b>최초 할당 값의 변경이 불가</b>하다 (변수의 타입 앞에 final을 붙이면 상수가 된다)

* 부가적으로 리터럴(literal)은 변수에서 <b>값 자체</b>를 의미한다

#### <변수 Type table>

|자료형|종류|범위|예시|
|:---:|:---:|:---:|:---:|
|byte|정수|1 byte, 2^8)|1, 50, 100|
|short|정수|2 byte, 2^16|1, 50, 100|
|int|정수|4 byte, 2^32|1, 50, 100|
|long|정수|8 byte, 2^64|1L, 50L, 100L|
|float|실수|4 byte, 2^32|0.1f, 0.5f, 3.14f|
|double|실수|8 byte, 2^64|0.1, 0.5, 3.14|
|boolean|false, true|1 byte|false, true|
|char|문자 하나|2 byte|'A', 'B', 'C'|
|Straing|문자열|동적 메모리 할당|"Java", "Programming", "Variable"|

******************************************************************************************************************************************************************************************

#### *변수 Type*

```java
int a = 100; / int type, 변수: a, literal: 100
double b = 3.14; / double type, 변수: b, literal: 3.14
boolean c  = false; / int type, 변수: c, literal: false
char d = 'a'; / int type, 변수: d, literal: a
String e = "java"; / int type, 변수: e, literal: java
```

******************************************************************************************************************************************************************************************

## 2. 연산자(Operator)


### 2. 연산자(Opeator)란?

* 연산을 수행하는 기호 / ex) +, -, *, /

* 연산자의 우선순위는 <b>사칙연산에 기초</b>한다

* <b>괄호</b>의 경우 <b>최우선 순위</b>, <b>대입 연산자 (=)</b>의 경우 가장 <b>후순위</b>다

#### <연산자 종류 Table>

|종류|연산자|설명|
|:---:|:---:|:---:|
|산술 연산자| +, -, *, /, %|사칙 연산과 나머지 연산(%)|
|증감 연산자| ++, --|증가 및 감소|
|비교 연산자| >, <, >=, <=, ==, !=|두 값을 비교|
|논리 연산자| &&(AND), ㅣㅣ(OR), !(NOT)|조건 연결 및 부정|
|대입 연산자| =|우변의 값을 좌변에 저장|
|삼항 연산자| ? :|항이 3개, 조건, 참, 거짓으로 구성|

***************************************************************************************************************************************************************************************

##### *연산자*

```java

//변수 선언 및 초기화 (대입)

int a = 1, b = 3;
String c = "ja", d = "va";

//산술

a + b = 4
a * b = 3
c + d = ("ja" + va")

//증감

a++ = 2 // a + 1
b-- = 2 // b - 1

//비교

a > b = false
c != b = true

```

******************************************************************************************************************************************************************************************

## 3.조건문(Conditional statements)

### 3. 조건문(Conditional statements)이란?

* Program의 <b>흐름을 제어하는 문장</b>이다, 조건에 따라 특정 영역 생략 혹은 수행을 구현할 수 있다

* if문, switch문이 있다

* 조건을 판별하는 영역과 행위를 정의하는 영역으로 구분된다

#### *조건문*

```java
//if 문

if (condition) {
true action
} else {
// false action
}

//switch 문

switch (condition) {
case condition 1 :
ondition 1 action
berak;

case condition 2 :
condition 2 action
break;

default:
default action
}
```

******************************************************************************************************************************************************************************************

#### 3. 1) if문

* 다중 조건이 요구될 경우 <b>if, else if</b>로 문장을 구성한다

* 다중 조건 중, <b>어느 경우에도 해당하지 않는 경우</b> else로 조건문을 마무리 지으며 이는 생략이 가능하다

* if문을 <b>중첩</b>하여 작성할 수 있다.

******************************************************************************************************************************************************************************************

#### 3. 2) switch문

* 조건에 비교 연산자 사용이 불가하며, <b>값의 일치 여부만을 비교하는 경우</b>에 사용한다

* break문이 없을 경우 후속 코드가 실행되기 때문에, <b>각 조건에 break문을 구성</b>해야 한다

* default는 조건 중 <b>어느 경우에도 해당하지 않는 경우 실행</b>되며, 통상적으로 switch문의 마지막에 구성되기에 해당 경우 break문이 필요하지 않다

******************************************************************************************************************************************************************************************

#### 3. 3) if문 vs switch문

* <b>switch문의 경우</b> true, false (비교 결과)의 조건이 아닌, 단순 값의 일치만 조건으로 설정할 수 있다. <b>사용 가능 경우가 국한</b>된다

* <b>if문의 경우</b> switch문의 제약 조건에 해당하지 않기에, 비교적 <b>범용성이 좋다</b>

* 결론적으로 <b>코드의 간결화</b>를 위해 <b>switch문</b>이 활용되며, 모든 경우 <b>if 문으로 구성하여도 기능적인 문제는 없다</b>

******************************************************************************************************************************************************************************************


## 4.반복문(Loop)

### 4. 반복문(Loop)이란?

* 특정 작업이 <b>반복적으로 수행</b>되도록 지시하는 명령문이다

* for문, while문, do-while문이 있다

* 크게 <b>조건식, 증감식, 행위 정의 영역</b>으로 구분된다

* 반복문을 <b>중첩하여 구성</b>할 수 있다.

#### *반복문*

```java
//for문

for(initialization, condition, update) {
action
}

//while문

initialzation
while(condition) {
action
update
}

//do-while문(조건과 관계 없이 do 영역 활성화)

initialzation
do{
action
} while(condition) {
action
update
}

```

******************************************************************************************************************************************************************************************

#### 4. 1) for문

* 초기화, 조건문, 증감식이 한 줄로 명시되어 있어 가독성이 좋다

* 변수의 Scope이 for문에 국한되어 본문의 변수와 별도로 관리가 가능하다

******************************************************************************************************************************************************************************************

#### 4. 2) while문

* while(true)를 통한 무한 Loop의 구현이 간단하다 while(true)

* 변수의 초기화가 while문 밖에서 수행되어, 본문의 변수와 별도로 관리가 불가하다

******************************************************************************************************************************************************************************************

#### 4. 3) do-while문

* 조건 충족 여부와 무관하게 수행되어야 할 행위가 있는 경우 활용한다

******************************************************************************************************************************************************************************************

## 5. 배열(Array)

### 5.1) 배열(Array)이란?

* <b>동일 Type의 복수 변수를 하나로 Group</b>으로 다루는 것이다 

* <b>다량의 변수가 요구될 때</b>, 반복되는 변수 선언에 대한 공수를 경감시킬 수 있다

******************************************************************************************************************************************************************************************

#### 5.2) 배열 변수 선언 및 생성

* 배열을 사용하기 위해서는 <b>배열 변수 선언 → 배열 생성</b>이 요구된다

* 배열 변수 선언과 배열 생성을 동시에 진행하면 간략히 한 줄로 표현할 수 있다.

* 배열의 범위는 <b>0 ~ 배열 수량-1</b> 까지 이다

* 배열 변수 자체는 <b>참조 변수</b>로써, <b>생성된 배열의 주소</b>을 가지고 있다


#### <배열 선언 방법 Table>

|선언방법|예시|
|:---:|:---:|
|타입[] 변수이름;|int[] num;|
|타입 변수이름[];|int num [];|

******************************************************************************************************************************************************************************************

#### 배열 선언 및 생성, 값 저장

```java

// 배열 변수 선언 & 배열 생성

//  타입[] 변수 = new 변수[수량];
    int[] num = new int[5]

// 총 5개의 int 값을 저장할 수 있는 저장 공간 확보 num[0] ~ num[4]
// int num = 5개의 int 값을 저장할 수 있는 저장 공간 주소 (참조 변수)

// 배열의 초기화

//  변수[번호] = 값;
    num[0] = 50; 
    num[4] = 100;

// 배열 변수 선언 & 배열 생성 & 초기화

// 타입 [] 변수 = {값0, 값1, 값2, 값3, 값4};
   int[] num = {50, 10, 20, 30, 100}

//순차적으로 값 저장
```

******************************************************************************************************************************************************************************************

#### 5.3) 다차원 배열

* 배열은 <b>다차원으로 구성할 수 있다</b>, 상기 *5.2) 배열 변수 선언 및 생성*의 예시는 1차원 배열에 해당한다

* 2차원 배열의 경우 [수량1][수량2]로 구성되는데, <b>생성되는 저장 공간은 수량1*수량2</b>이다(수량1 행 수량2 열)

#### <2차원 배열 선언 방법 Table>

|선언방법|예시|
|:---:|:---:|
|타입[][] 변수이름;|int[][] num;|
|타입 변수이름[][];|int num [][];|
|타입[] 변수이름[];|int[] score[];|

#### <2차원 배열 선언 예시>

```java
* int[][] num = new int[5][2]
// 5행 2열의 배열 선언, 총 10개의 저장 공간 확보
```

| |0|1|
|:---:|:---:|:---:|
|0|num[0][0]|num[0][1]|
|1|num[1][0]|num[1][1]|
|2|num[2][0]|num[2][1]|
|3|num[3][0]|num[3][1]|
|4|num[4][0]|num[4][1]|

******************************************************************************************************************************************************************************************

#### 2차원 배열 선언 및 생성, 값 저장

```java

// 배열 변수 선언 & 배열 생성 & 초기화

/* 타입 [][] 변수 = {값1, 값2, 값3},
                    {값4, 값5, 값6}; */
   int[][] num = {1,2,3},
                 {4,5,6};


```

******************************************************************************************************************************************************************************************

## 6. 객체지향 프로그래밍 1

### 객체지향 프로그래밍이란?

* <b>독립된 기능</b>을 가진 대상들을 <b>유기적으로 연결</b>하여 작업을 구현하는 것이다

* 코드의 <b>재사용성이 우수</b>하며 각 코드의 <b>관리가 용이</b>하다(유지보수)


******************************************************************************************************************************************************************************************


#### 6.1) 클래스와 객체

* 클래스란 <b>객체를 정의</b>하는데 사용된다

* 객체란 클래스의 정의된 내용대로 <b>메모리에 생성</b>되는 것을 의미한다

* 객체는 <b>속성(변수)</b>과 <b>기능(메서드)</b>로 구성되어 있다. 객체가 가지고 있는 속성과 기능을 <b>Member</b>라고 칭한다

* 클래스로부터 객체를 생성하는 과정을 <b>인스턴스화(Intantiate)</b>라고 하며, 생성된 객체는 해당 클래스의 <b>인스턴스(Instance)</b>라 칭한다

* Class 작성 시, Public class는 Source 파일과 이름이 <b>일치</b>해야한다(<b>외부에서 접근 가능</b>)

* Public이 없는 Class의 경우 이름이 일치하지 않아도 무관하다(단 </b>외부에서 접근 불가능<b>)


#### 객체의 구성요소, 속성과 기능 예시
```java

// Tv인스턴스의 멤버 변수 초기화
    Tv t;
    t = new Tv();
    t.channel = 7;
    t.channelDown();


Class TV {

    String color; // 색상
    boolean power; // 전원
    int channel; //채널

    void power() { power = !power;} //전원 제어
    void channelUp() { channel++; } // 채널 증가
    void channelDown() { channel--; } // 채널 감소

```

#### <객체의 생성>

|선언방법|예시|
|:---:|:---:|
|클래스명 변수명;|Tv t;|
|변수명 = new 클래스명();|t = new Tv();|

#### 객체 생성의 간결화

```java

Tv t1 = new Tv(); // 참조 변수에 인스턴스 생성을 한줄로 간결하게 작성할 수 있다


```

******************************************************************************************************************************************************************************************


#### 6.2) 객체배열

* 객체 역시 <b>배열</b>로 다룰 수 있다(참조 변수들을 하나로 묶은 <b>참조 변수 배열</b>이다)

  #### 객체 배열

```java

// Tv tv1, tv2, tv3;
Tv[] tvArr = new Tv[3];

tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// Tv[] tvArr = { new Tv(), new Tv(), new Tv() } 로 간결한 작성 가능

```

******************************************************************************************************************************************************************************************

#### 6.3) 선언위치에 따른 변수의 종류

* 클래스 변수, 인스턴스 변수, 지역 변수가 있다

* 멤버 변수를 제외한 나머지 변수들은 모두 지역 변수, 멤버 변수중 static이 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수이다

#### <선언위치에 따른 변수의 종류 Table>

|변수의 종류|선언 위치|생성시기|
|:---:|:---:|:---:|
|클래스 변수(class variable)|클래스 영역|클래스가 메모리에 올라갈 때|
|인스턴스 변수(instance variable)|클래스 영역|인스턴스가 생성시|
|지역 변수(local variable)|클래스 영역 이외 영역(메서드, 생성자, 초기화 블럭 내부)|변수 선언문이 수행되었을 때|

#### 선언위치에 따른 변수의 종류

```java

class Variables {

    int a;           // 인스턴스 변수
    static int b;    // 클래스 변수

    void method() {
        int a = 0;   // 지역 변수
    }
}

```

******************************************************************************************************************************************************************************************


#### 6.4) 메서드

* 메서드란 특정 작업을 구현하는 문장을 <b>Grouping</b> 한 것이다

* <b>선언부(header)</b>와 <b>구현부(body)</b>로 구성되어 있다

* 변수 타입의 <b>생략은 불가능</b>하다

* return문은 필수요소이다

* 반환 <b>값이 없을 경우</b> 반환타입으로 <b>void</b>를 작성한다(void의 경우 return문 생략이 가능하다, 다만 이는 컴파일러가 자동으로 추가해주기 때문이다)

* Return문의 경우 반환 값이 메서드의 타입과 <b>일치 혹은 자동 형 변환이 가능</b>한 것이여야 한다(자동 형 변환은 작은 범위의 변수에서 같거나 큰 범위의 변수로 전환할 때 가능하다)

* <b>하나의 값</b>만 반환할 수 있다

* 동일 클래스에 소속된 멤버들 간에는 별도 인스턴스 생성 없이 참조 혹은 호출이 가능하다

#### 메서드 작성

```java

class Variables {

int add(int a, int b) {      // 선언부: 반환타입 메서드이름 (타입 변수, 타입 변수)
    int reuslt = a + b;      // 구현부
    return result;           // 구현부

// return a+b; 간결한 표현 가능 

}

```
******************************************************************************************************************************************************************************************

#### 6.5) 참조형 매개변수와 반환

* 매개변수와 반환타입 모두 참조형이 될 수 있다

* 하나의 값만 반환할 수 있다

#### 참조형 매개변수

```java

class Data { int x; }

class Ex {
    public static void main(String[]args) {
        Data d = new Data();
        d.x = 10;

        change(d) // d.x = 1000 값 변경
    }

    static void chnage(Data d) {
        d.x = 1000;
    }
}

```

#### 참조형 반환타입

```java

class Data { int x; }

class Ex {
    public static void main(String[]args) {
        Data d = new Data();
        d.x = 10;

        data d2 = copy(d)

        copy(d) // d.x = 1000 값 변경
    }

    static void copy(Data d) {
        Data tep = new Data(); // 객체 생성
        tmp.x = d.x;
        return tmp;
}

```

******************************************************************************************************************************************************************************************

#### 6.6) static과 인스턴스

* 변수와 메서드 앞에 static이 붙어 있으면 <b>객체를 생성하지 않고도</b> 클래스 이름.메서드 이름(매개변수)로 <b>호출이 가능하다</b>(인스턴스는 <b>반드시 객체를 생성</b>해야 <b>호출이 가능하다</b>)

* 멤버변수 중 모든 인스턴스에 공통으로 사용되는 것에 static을 붙인다

* 클래식 메서드는 인스턴스 변수 및 메서드를 사용할 수 없다

******************************************************************************************************************************************************************************************

#### 6.7) 오버로딩(overloading)

* 메서드 이름이 동일해도, 매개변수의 개수 혹은 타입이 상이하면 같은 이름을 사용해서 메서드를 정의할 수 있다 (반환타입은 상이하여도 오버로딩이 불가하다)

#### 오버로딩

```java

static double add(double a, int b) {
        return a + b;
    }
static double add(int a, double b) {
        return a + b;
    }

```

******************************************************************************************************************************************************************************************

#### 6.8) 생성자(constructor)

* 인스턴스 초기화 메서드로, <b>인스턴스 변수 초기화 작업</b>에 주로 활용된다

* 생성자의 이름은 <b>클래스와 동일</b>해야하며, <b>반환 값은 없다</b>(다만 void는 <b>생략이 가능</b>하다)

* 생성자는 모든 클래스에 필수 요소이나, 클래스 내 생성자가 없을 시 컴파일러가 자동으로 생성한다(생략 가능)

* 클래스이름(타입 변수, 타입 변수) { 인스턴스 변수 초기화 코드}

* this는 동일 클래스 내 다른 생성자를 호출할 때 사용되고, 인스턴스 자신을 가리키는 참조변수로써 활용된다

#### 생성자

```java

Car(String color, String gearType, int door) { // this.변수는 인스턴스 변수, color는 지역변수로 구분된다
    this.color = color;                        // this는 인스턴스 자신을 의미한다
    this.gearType = gearType;
    this.door = door;

Car() {
    this("White", "auto", 4); // Car(String color, String gearType, int door)를 호출
    }
Car(String color){            // Car(String color, String gearType, int door)를 호출
    this(color, "auto", 4)
    }
    
```

******************************************************************************************************************************************************************************************

#### 6.9) 변수의 초기화

* 멤버변수는 자동적으로 기본값으로 초기화가 지원되지만,<b>지역변수는 사용 전 반드시 초기화</b>해야한다

* 클래스 변수의 초기화가 인스턴스 변수의 초기화보다 우선 수행된다

  
#### <선언위치에 따른 변수의 종류 Table>

|자료형|기본값|
|:---:|:---:|
|boolean|false|
|char|'/u0000'|
|byte, short, int|0|
|long|0L|
|float|0.0f|
|double|0.0(0.0d)|
|참조형|null|

******************************************************************************************************************************************************************************************

## 7. 객체지향 프로그래밍 2

### 7-1) 상속

* 기존의 클래스를 <b>재사용</b>하여 <b>새로운 클래스를 작성</b>하는 것이다

* 새로 작성하고자 하는 Child 클래스의 이름 뒤 상속을 의미하는 'extands'와 상속받고자 하는 Parent 클래스의 이름을 함께 작성하여 상속시킨다

* Child 클래스는 Parent 클래스의 모든 멤버를 상속받는다(생성자 및 초기화 제외)

* Child 클래스의 멤버 개수는 Parent 클래스보다 같거나 많을 수 밖에 없다

* <b>단일 클래스</b>로부터의 상속받는 것을 허용한다


#### 상속

```java

class Parent{}
class Child extends Parent

```

#### 상속 예제

```java

    public static void main(String[] args) {
        SmartTv stv = new SmartTv();
        stv.channel = 10;                    // Parent class (Tv)로부터 상속받은 멤버
        stv.channelUp();                     // Parent class (Tv)로부터 상속받은 멤버
        stv.displayCaption("Hello, world");
        stv.caption = true;
        stv.displayCaption("Hello, world");
    }
}

class Tv {
    boolean power;
    int channel;

    void power() { power = !power;}
    void channelUp() { ++channel; }
    void channelDown() { --channel; }
    }

class SmartTv extends Tv {                     // SmartTv는 기존 Tv에 Caption 기능 추가
    boolean caption;
    void displayCaption(String text) {
        if (caption) {
            System.out.println(text);
        }
    }
}

// RESULT:
// Hellow, world

```
******************************************************************************************************************************************************************************************

### 7.2) 포함

* 상속 이외에도 재사용하는 방법이 <b>포함</b>이다, 한 클래스의 멤버변수로 다른 클래스 타입의 <b>참조변수를 선언</b>하는 것이다

* '~는 이다'는 상속관계, '~는 ~를 가지고 있다'는 포함관계로 맺어주는 것이 적절하다

  
#### 상속

```java

class Car {
    Engine E = new engine();
    Door[] d = new Door[4];
    }

```

******************************************************************************************************************************************************************************************

### 7.3) 오버라이딩(overriding)

* Parent 클래스로부터 상속받은 메서드의 내용을 변경하는 것이다

* 동일한 메서드명을 통해 변동된 환경에 맞는 결과를 도출할 수 있다

* 선언부가 Parent 클래스와 일치해야 한다

* 접근 제어자를 Parent 클래스보다 좁은 범위로 변결할 수 없다

* 예외는 Parent 클래스의 메서드보다 많이 선언할 수 없다

#### 상속

```java

  class Point {
        int x, y;
        
        String getLocation() {
            return "x: " + x + ", y: " + y;
        }
    }
    
    class Point3D extends Point {
        int z;
        
        String getLocation() {
            return "x: " + x + ", y" + y + ", z: " + z;

```

******************************************************************************************************************************************************************************************

### 7.4) 참조변수 super

* 상속받은 멤버와 자신의 멤버 이름이 동일할 때, super를 붙여서 구별할 수 있다

* 생성자는 상속되지 않는다

* 클래스 자신에 선언된 변수는 자신의 생성자가 초기화를 책임지도록 작성하는 것이 바람직하다

#### 참조변수 super

```java

 public static void main(String[] args) {
        Child c = new Child();
        c.method();
    }
}
    class Parent {
        int x = 10;                         // super.x
    }

    class Child extends Parent {
        int x = 20;                         // this.x

        void method() {
            System.out.println("x= " + x);
            System.out.println("this.x= " + this.x);
            System.out.println("super.x= " + super.x);
        }
    }

// RESULT:
// x= 20
// thix.x= 20
// super.x= 10

```

#### super() — 조상의 생성자

```java

public static void main(String[] args) {
        Point3D p = new Point3D(1, 2, 3);
        System.out.println("x= " + p.x + ", y= " + p.y + ", z= " + p.z);
    }
}

class Point {
    int x, y;

    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}

class Point3D extends Point {
    int z;

    Point3D(int x, int y, int z) {
        super(x, y);                    // Point(int x, int y)를 호출
        this.z = z;
    }
}

```

******************************************************************************************************************************************************************************************

### 7.5) 패키지(package)

* 클래스의 묶음이다, 관련된 클래스를 그룹 단위로 묶어 효율적으로 관리할 수 있다

* 같은 이름의 클래스도 서로 다른 패키지에 존재하는 것이 가능하다

* 패키지는 하위 패키지를 포함할 수 있다.

* 패키지는 클래스명과 쉽게 구분하기 위해서 소문자로 작성하는 것이 관행이다

* Source 파일에서 주석과 공백을 제외한 첫 번째 문장이여야 한다

#### 패키지 선언

```java
package 패키지명;
```
******************************************************************************************************************************************************************************************

### 7.6) import문

* 다른 패키지의 클래스를 사용하려면 패지키명이 포함된 클래스 이름을 사용해야한다, impor문은 사용하고자 하는 클래스의 패키지를 선제적으로 명시하여 패키지명을 생략시킨다

* 동일 패키지에서 복수의 클래스를 사용할 때, 클래스 이름 대신 '*'을 사용하면 해당 패키지의 모든 클래스를 사용할 수 있다

* static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다

#### import문

```java
import package 패키지명.클래스명;

import 패키지명.*;
```

#### import문 예시

```java
java.util.Date today = new java util.Date(); // import문 선언시: import java.util.Data;
                                           //                  Date today = new Data;                 
```

#### static import문

```java
import static java.lang.Integer.*;   // Integer클래스의 모든 static 메서드
import static java.lang.Math.random; // Math.random()만, 괄호는 생략한다
import static java.lang.System.out;  // System.out을 out만으로 참조가능

System.out.println(Math.random()); // static import문 후 > out.println(random());
```

#### static import문 예시
```java
package Test;

import static java.lang.System.out;
import static java.lang.Math.*;

public class Example {
    public static void main(String[] args) {
      out.println(random());
      out.println("Math.PI: " + PI);
    }
}
```

******************************************************************************************************************************************************************************************

### 7.7) 제어자(Modifier)

* 클래스, 변수 혹은 메서드의 선언부에 함게 사용된다

* 접근제어자와 그 외의 제어자로 분류된다

* 접근제어자: public, protected, (default), private

* 그 외 제어자: static, final, abstract, native, transient, synchronzied, volatile, strictfp

******************************************************************************************************************************************************************************************

### 7.8) static

* static은 '클래스의' 혹은 '공통적인' 의미를 가지고 있다

* static이 사용될 수 있는 곳은 '멤버변수, 메서드, 초기화 블럭'이다


#### <static summary table>

|제어자|대상|의미|
|:---:|:---:|:---:|
|static|멤버변수|모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다 <br/> 클래수 변수는 인스턴스를 생성하지 않아도 사용 가능하다 <br/> 클래스가 메모리에 로드될 때 성생된다|
|static|메서드|인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다 <br/> static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다|

******************************************************************************************************************************************************************************************

### 7.9) final

* final은 '마지막의' 혹은 '변경될 수 없는' 의미를 가지고 있다

* 변수에 사용되면 값을 변경할 수 없는 상수가 된다

* 메서드에 사용하면 오버라이딩이 불가하게 된다

* 클래스에 사용되면 자신을 확장하는 Child 클래스를 정의하지 못하게 된다

* final이 사용될 수 있는 곳은 '클래스, 메서드, 멤버변수, 지역변수'이다

#### <final summary table>

|제어자|대상|의미|
|:---:|:---:|:---:|
|final|클래스|변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다 </br> final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다|
|final|메서드|변경될 수 없는 메서드 </br> final로 지정된 메서드는 오버라이딩을 통해 재 정의 될 수 없다|
|final|멤버변수|변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다|
|final|지역변수|변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다|

******************************************************************************************************************************************************************************************

### 7.10) abstract

* abstract는 '미완성'의 의미를 가지고 있다

* abstract가 사용될 수 있는 곳은 '클래스, 메서드'이다

* 추상 클래스는 말 그대로 미완성을 의미하므로 인스턴스를 생성할 수 없다

#### <abstract summary table>

|제어자|대상|의미|
|:---:|:---:|:---:|
|abstract|클래스|클래스 내에  추상 메서드가 선언되어 있음을 의미한다|
|abstract|메서드|선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다|

******************************************************************************************************************************************************************************************

### 7.11) 접근 제어자(access modifier)

* 외부에서 접근하지 못하도록 제한하는 역할이다

* default는 생략된다, 즉 접근 제어자가 지정되어 있지 않다면 접근 제어자가 default라는 의미이다

* 접근자가 사용될 수 있는 곳은 '클래스, 멤버변수, 메서드, 생성자'이다

* 각 접근 제어자의 접근 범위 크기의 관계는 같다, public > protected > (default) > private

* 외부로부터 데이터를 보호하거나, 외부에는 불필요한 영역을 감추기 위해 사용된다, 이를 캡슐화(encapsulation)이라 한다

* 통상적으로 멤버변수의 값을 읽는 메서드를 'get멤버변수이름'(getter), 멤버변수의 값을 변경하는 메서드의 이름을 'set멤버변수이름'(setter)으로한다

#### <접근 제어자 table>

|접근 제어자|의미
|:---:|:---:|
|private|같은 클래스 내에서만 접근이 가능하다|
|(default)|같은 패키지 내에서만 접근이 가능하다|
|protected|같은 패키지 내에서, 그리고 다른 패캐지의 자손클래스에서 접근이 가능하다|
|public|접근 제한이 전혀 없다|

#### <접근 제어자 접근 범위 table>

|제어자|같은 클래스|같은 패키지|자손 클래스|전   체|
|:---:|:---:|:---:|:---:|:---:|
|public|O|O|O|O|
|protected|O|O|O||
|(default)|O|O||||
|private|O|||||

#### static import문 예시
```java
class Time {
    private int hour, minute, second; // 외부에서 직접 접근하지 못하도록 설정한다

    public int getHour() { return hour;}
    public void setHour(int hour) {
        if (hour < 0 || hour > 23) return;
        this.hour = hour;
    }
    public int getMinute() { return minute;}
    public void getMinute(int minute){
        if (minute < 0 || minute > 59) return;
        this.minute = minute;
    }
    public int getSecond(){return second;}
    public void setSecond() {
        if (second < 0 || second > 59) return;
        this.second = second;
    }
}
```
******************************************************************************************************************************************************************************************

### 7.12) 다형성(polymorphism)

* 여러 가지 형태를 가질 수 있는 능력을 의미한다

* 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 구성되었다

* 같은 타입의 인스턴스지만 참조변수 타입에 따라 사용 할 수 있는 멤버의 개수가 달라진다

* 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 불가능하다(항시 자손타입이 멤버가 더 많기 때문이다)
 
#### static import문 예시
```java
class Tv {
    boolean power;
    int channel;

    void power() {power = !power;}
    void channelUp() { ++channel;}
    void channelDown() {--channel;}
}

class SmartTv extends Tv {
    String text;
    void caption() {}
}

SmartTv s = new SmartTv();    // 참조 변수와 인스턴스의 타입이 일치
Tv t = new SmartTv();         // 조상 타입 참조변수로 자손 타입 인스턴스 참조: Tv 타입의 참조변수 t는 인스턴스가 smartTv이더라도, smartTv의 모든 멤버를 사용할 수 없다
```
******************************************************************************************************************************************************************************************

### 7.13) 참조변수의 형변환

* 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능하다

* 참조형의 형변환은 변수에 저장된 값이 변환되는 것이 아니다,다른 타입으로 변경되는 것이다(사용할 수 있는 멤버의 개수가 변경)

* 상호 상속관계에 있는 타입은 형변환이 자유로이 가능하다

* 참조 변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다 (

#### 참조변수의 형변환

```java
class Car {}
class FireEngine extends Car{}
class Ambulance extends Car{}

FireEngine f = new FireEngine();     
Car c = Car f;                      // OK 생략 가능: Car c= f; | 조상인 Car타입으로 형변환 > 조상타입은 자손타입보다 멤버가 적으므로 생략이 가능하다
FireEngine f2 = (FireEngine)c;      // OK 자손인 FireEngine타입으로 형변환(생략 불가) > 자손타입은 조상타입보다 멤버가 많으므로 생략이 불가하다
ambulance a = (Ambulance)f;         // Error 상손관계가 아니므로 형변환 불가
```
#### 참조변수의 예시
```java
   Car car = null;
    FireEngine fe = new FireEngine();
    FireEngine fe2 = null;

    fe.water();
    car = fe; // car = (Car)fe;에서 형변환이 생략됨
//  car.water(); Car 타입의 참조변수로는 water()를 호출할 수 없다
    fe2 = (FireEngine)car;
    fe2.water();

    }
}
class Car {
    String color;
    int door;

    void drive(){
        System.out.println("drive");
    }
    void stop(){
        System.out.println("stop");
    }
}

class FireEngine extends Car {
    void water() {
        System.out.println("water");
    }
}

// RESULT:
// water
// water

```

******************************************************************************************************************************************************************************************

### 7.26) instanceof 연산자

* 참조변수가 검사한 타입으로 형변환이 가능한지 확인할 수 있다

* 주로 조건문에 사용되며, '참조변수 instanceof 타입(클래스 명)'의 형태로 true와 false중의 하나를 반환한다

* 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다

  
```java

void doWork(Car c) {
    if (c istanceof FireEngine) {        // 1. 형변환이 가능한지 확인
        Fireengine fe = (FireEngine)c;   // 2. 형변환
        fe.water();

```

******************************************************************************************************************************************************************************************

### 7.26) 매개변수의 다형성

```java
   public static void main(String[] args) {
        Buyer b = new Buyer();

        b.buy(new Tv());
        b.buy(new Computer());
        System.out.println("현재 남은 돈은" + b.money + "만원입니다.");
        System.out.println("현재 보너스 점수는" + b.bonusPoint + "점입니다.");
    }
}

class Product {
    int price;
    int bonusPoint;

    Product(int price) {
        this.price = price;
        bonusPoint = (int)(price/10.0);
    }
}

class Tv extends Product {
    Tv() {
        super(100);}
    public String toString(){return "Tv";}
}
class Computer extends Product {
    Computer(){super(200);}
    public String toString(){return "Computer";}
}

class Buyer {
    int money = 1000;
    int bonusPoint = 0;

    void buy(Product p) {
        if(money < p.price) {
            System.out.println("잔액이 부족하여 물건을 살 수 없습니다.");
            return;
        }

        money -= p.price;
        bonusPoint += p.bonusPoint;
        System.out.println(p + "을/를 구매하셨습니다.");
    }
}

*/ Result:
Tv을/를 구매하셨습니다.
Computer을/를 구매하셨습니다.
현재 남은 돈은700만원입니다.
현재 보너스 점수는30만원입니다.
*/
```

******************************************************************************************************************************************************************************************
