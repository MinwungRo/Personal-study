# INDEX_Java

![image](https://github.com/MinwungRo/Personal-study/assets/167000133/b1459b23-15d1-4ff7-9067-56e8ef2b3182)

1. [변수(Variable)](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#1-%EB%B3%80%EC%88%98variable)

2. [연산자(Operator)](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#2-%EC%97%B0%EC%82%B0%EC%9E%90operator)

3. [조건문(Conditional statement)](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#3%EC%A1%B0%EA%B1%B4%EB%AC%B8conditional-statements)

4. [반복문(Loop)](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#4%EB%B0%98%EB%B3%B5%EB%AC%B8loop)

5. [배열(Array)](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#5-%EB%B0%B0%EC%97%B4array)

6. [객체지향 프로그래밍 1](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#6-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1)

7. [객체지향 프로그래밍 2](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#7-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-2)

8. [예외 처리](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#8-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-exception-handling)

9. [java.lang 패키지와 유용한 클래스](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#9-javalang%ED%8C%A8%ED%82%A4%EC%A7%80%EC%99%80-%EC%9C%A0%EC%9A%A9%ED%95%9C-%ED%81%B4%EB%9E%98%EC%8A%A4)

10. [날짜와 시간](https://github.com/MinwungRo/Personal-study/blob/main/Java/README.md#10-%EB%82%A0%EC%A7%9C%EC%99%80-%EC%8B%9C%EA%B0%84)
******************************************************************************************************************************************************************************************

## 1. 변수(Variable)


### 1. 변수(Variable)란?

* 값을 저장할 수 있는 저장 공간

* Memory의 특정 공간을 확보하여 해당 공간에 데이터를 할당할 수 있다

* 변수가 필요하다면 먼저 <b>변수 선언</b>이 선행되어야 한다 (저장 공간 확보)

* 변수 선언 후 <b>초기화(최초 값 부여)</b>가 필요하다, Computer의 Memory는 복수의 대상과 유기적인 관계를 형성하고 있어 <b>특정 값이 할당</b>되어 있다. 따라서 변수를 초기화 하지 않으면 <b>예상치 못한 값이 출력</b>될 수 있다

#### *변수 선언 및 초기화*

```java
변수타입 변수이름; // 변수 선언
변수타입 변수이름 = 값; // 변수 초기화
```

******************************************************************************************************************************************************************************************

#### 1. 2) 변수 Type

* 변수는 값의 형태 및 크기에 따라 해당하는 <b>Type(형식)</b>이 존재한다

* long, double 형의 경우 <b>접미사를 포함</b>하여 값을 입력해야 한다

* 상수(constant)는 변수와 마찬가지로 값을 저장하는 공간이지만, <b>최초 할당 값의 변경이 불가</b>하다 (변수의 타입 앞에 final을 붙이면 상수가 된다)

* 부가적으로 리터럴(literal)은 변수에서 <b>값 자체</b>를 의미한다

#### <변수 Type table>

|자료형|종류|범위|예시|
|:---:|:---:|:---:|:---:|
|byte|정수|1 byte, 2^8)|1, 50, 100|
|short|정수|2 byte, 2^16|1, 50, 100|
|int|정수|4 byte, 2^32|1, 50, 100|
|long|정수|8 byte, 2^64|1L, 50L, 100L|
|float|실수|4 byte, 2^32|0.1f, 0.5f, 3.14f|
|double|실수|8 byte, 2^64|0.1, 0.5, 3.14|
|boolean|false, true|1 byte|false, true|
|char|문자 하나|2 byte|'A', 'B', 'C'|
|Straing|문자열|동적 메모리 할당|"Java", "Programming", "Variable"|

******************************************************************************************************************************************************************************************

#### *변수 Type*

```java
int a = 100; / int type, 변수: a, literal: 100
double b = 3.14; / double type, 변수: b, literal: 3.14
boolean c  = false; / int type, 변수: c, literal: false
char d = 'a'; / int type, 변수: d, literal: a
String e = "java"; / int type, 변수: e, literal: java
```

******************************************************************************************************************************************************************************************

## 2. 연산자(Operator)


### 2. 연산자(Opeator)란?

* 연산을 수행하는 기호 / ex) +, -, *, /

* 연산자의 우선순위는 <b>사칙연산에 기초</b>한다

* <b>괄호</b>의 경우 <b>최우선 순위</b>, <b>대입 연산자 (=)</b>의 경우 가장 <b>후순위</b>다

#### <연산자 종류 Table>

|종류|연산자|설명|
|:---:|:---:|:---:|
|산술 연산자| +, -, *, /, %|사칙 연산과 나머지 연산(%)|
|증감 연산자| ++, --|증가 및 감소|
|비교 연산자| >, <, >=, <=, ==, !=|두 값을 비교|
|논리 연산자| &&(AND), ㅣㅣ(OR), !(NOT)|조건 연결 및 부정|
|대입 연산자| =|우변의 값을 좌변에 저장|
|삼항 연산자| ? :|항이 3개, 조건, 참, 거짓으로 구성|

***************************************************************************************************************************************************************************************

##### *연산자*

```java

//변수 선언 및 초기화 (대입)

int a = 1, b = 3;
String c = "ja", d = "va";

//산술

a + b = 4
a * b = 3
c + d = ("ja" + va")

//증감

a++ = 2 // a + 1
b-- = 2 // b - 1

//비교

a > b = false
c != b = true

```

******************************************************************************************************************************************************************************************

## 3.조건문(Conditional statements)

### 3. 조건문(Conditional statements)이란?

* Program의 <b>흐름을 제어하는 문장</b>이다, 조건에 따라 특정 영역 생략 혹은 수행을 구현할 수 있다

* if문, switch문이 있다

* 조건을 판별하는 영역과 행위를 정의하는 영역으로 구분된다

#### *조건문*

```java
//if 문

if (condition) {
true action
} else {
// false action
}

//switch 문

switch (condition) {
case condition 1 :
ondition 1 action
berak;

case condition 2 :
condition 2 action
break;

default:
default action
}
```

******************************************************************************************************************************************************************************************

#### 3. 1) if문

* 다중 조건이 요구될 경우 <b>if, else if</b>로 문장을 구성한다

* 다중 조건 중, <b>어느 경우에도 해당하지 않는 경우</b> else로 조건문을 마무리 지으며 이는 생략이 가능하다

* if문을 <b>중첩</b>하여 작성할 수 있다.

******************************************************************************************************************************************************************************************

#### 3. 2) switch문

* 조건에 비교 연산자 사용이 불가하며, <b>값의 일치 여부만을 비교하는 경우</b>에 사용한다

* break문이 없을 경우 후속 코드가 실행되기 때문에, <b>각 조건에 break문을 구성</b>해야 한다

* default는 조건 중 <b>어느 경우에도 해당하지 않는 경우 실행</b>되며, 통상적으로 switch문의 마지막에 구성되기에 해당 경우 break문이 필요하지 않다

******************************************************************************************************************************************************************************************

#### 3. 3) if문 vs switch문

* <b>switch문의 경우</b> true, false (비교 결과)의 조건이 아닌, 단순 값의 일치만 조건으로 설정할 수 있다. <b>사용 가능 경우가 국한</b>된다

* <b>if문의 경우</b> switch문의 제약 조건에 해당하지 않기에, 비교적 <b>범용성이 좋다</b>

* 결론적으로 <b>코드의 간결화</b>를 위해 <b>switch문</b>이 활용되며, 모든 경우 <b>if 문으로 구성하여도 기능적인 문제는 없다</b>

******************************************************************************************************************************************************************************************


## 4.반복문(Loop)

### 4. 반복문(Loop)이란?

* 특정 작업이 <b>반복적으로 수행</b>되도록 지시하는 명령문이다

* for문, while문, do-while문이 있다

* 크게 <b>조건식, 증감식, 행위 정의 영역</b>으로 구분된다

* 반복문을 <b>중첩하여 구성</b>할 수 있다.

#### *반복문*

```java
//for문

for(initialization, condition, update) {
action
}

//while문

initialzation
while(condition) {
action
update
}

//do-while문(조건과 관계 없이 do 영역 활성화)

initialzation
do{
action
} while(condition) {
action
update
}

```

******************************************************************************************************************************************************************************************

#### 4. 1) for문

* 초기화, 조건문, 증감식이 한 줄로 명시되어 있어 가독성이 좋다

* 변수의 Scope이 for문에 국한되어 본문의 변수와 별도로 관리가 가능하다

******************************************************************************************************************************************************************************************

#### 4. 2) while문

* while(true)를 통한 무한 Loop의 구현이 간단하다 while(true)

* 변수의 초기화가 while문 밖에서 수행되어, 본문의 변수와 별도로 관리가 불가하다

******************************************************************************************************************************************************************************************

#### 4. 3) do-while문

* 조건 충족 여부와 무관하게 수행되어야 할 행위가 있는 경우 활용한다

******************************************************************************************************************************************************************************************

## 5. 배열(Array)

### 5.1) 배열(Array)이란?

* <b>동일 Type의 복수 변수를 하나로 Group</b>으로 다루는 것이다 

* <b>다량의 변수가 요구될 때</b>, 반복되는 변수 선언에 대한 공수를 경감시킬 수 있다

******************************************************************************************************************************************************************************************

#### 5.2) 배열 변수 선언 및 생성

* 배열을 사용하기 위해서는 <b>배열 변수 선언 → 배열 생성</b>이 요구된다

* 배열 변수 선언과 배열 생성을 동시에 진행하면 간략히 한 줄로 표현할 수 있다.

* 배열의 범위는 <b>0 ~ 배열 수량-1</b> 까지 이다

* 배열 변수 자체는 <b>참조 변수</b>로써, <b>생성된 배열의 주소</b>을 가지고 있다


#### <배열 선언 방법 Table>

|선언방법|예시|
|:---:|:---:|
|타입[] 변수이름;|int[] num;|
|타입 변수이름[];|int num [];|

******************************************************************************************************************************************************************************************

#### 배열 선언 및 생성, 값 저장

```java

// 배열 변수 선언 & 배열 생성

//  타입[] 변수 = new 변수[수량];
    int[] num = new int[5]

// 총 5개의 int 값을 저장할 수 있는 저장 공간 확보 num[0] ~ num[4]
// int num = 5개의 int 값을 저장할 수 있는 저장 공간 주소 (참조 변수)

// 배열의 초기화

//  변수[번호] = 값;
    num[0] = 50; 
    num[4] = 100;

// 배열 변수 선언 & 배열 생성 & 초기화

// 타입 [] 변수 = {값0, 값1, 값2, 값3, 값4};
   int[] num = {50, 10, 20, 30, 100}

//순차적으로 값 저장
```

******************************************************************************************************************************************************************************************

#### 5.3) 다차원 배열

* 배열은 <b>다차원으로 구성할 수 있다</b>, 상기 *5.2) 배열 변수 선언 및 생성*의 예시는 1차원 배열에 해당한다

* 2차원 배열의 경우 [수량1][수량2]로 구성되는데, <b>생성되는 저장 공간은 수량1*수량2</b>이다(수량1 행 수량2 열)

#### <2차원 배열 선언 방법 Table>

|선언방법|예시|
|:---:|:---:|
|타입[][] 변수이름;|int[][] num;|
|타입 변수이름[][];|int num [][];|
|타입[] 변수이름[];|int[] score[];|

#### <2차원 배열 선언 예시>

```java
* int[][] num = new int[5][2]
// 5행 2열의 배열 선언, 총 10개의 저장 공간 확보
```

| |0|1|
|:---:|:---:|:---:|
|0|num[0][0]|num[0][1]|
|1|num[1][0]|num[1][1]|
|2|num[2][0]|num[2][1]|
|3|num[3][0]|num[3][1]|
|4|num[4][0]|num[4][1]|

******************************************************************************************************************************************************************************************

#### 2차원 배열 선언 및 생성, 값 저장

```java

// 배열 변수 선언 & 배열 생성 & 초기화

/* 타입 [][] 변수 = {값1, 값2, 값3},
                    {값4, 값5, 값6}; */
   int[][] num = {1,2,3},
                 {4,5,6};


```

******************************************************************************************************************************************************************************************

## 6. 객체지향 프로그래밍 1

### 객체지향 프로그래밍이란?

* <b>독립된 기능</b>을 가진 대상들을 <b>유기적으로 연결</b>하여 작업을 구현하는 것이다

* 코드의 <b>재사용성이 우수</b>하며 각 코드의 <b>관리가 용이</b>하다(유지보수)


******************************************************************************************************************************************************************************************


#### 6.1) 클래스와 객체

* 클래스란 <b>객체를 정의</b>하는데 사용된다

* 객체란 클래스의 정의된 내용대로 <b>메모리에 생성</b>되는 것을 의미한다

* 객체는 <b>속성(변수)</b>과 <b>기능(메서드)</b>로 구성되어 있다. 객체가 가지고 있는 속성과 기능을 <b>Member</b>라고 칭한다

* 클래스로부터 객체를 생성하는 과정을 <b>인스턴스화(Intantiate)</b>라고 하며, 생성된 객체는 해당 클래스의 <b>인스턴스(Instance)</b>라 칭한다

* Class 작성 시, Public class는 Source 파일과 이름이 <b>일치</b>해야한다(<b>외부에서 접근 가능</b>)

* Public이 없는 Class의 경우 이름이 일치하지 않아도 무관하다(단 </b>외부에서 접근 불가능<b>)


#### 객체의 구성요소, 속성과 기능 예시
```java

// Tv인스턴스의 멤버 변수 초기화
    Tv t;
    t = new Tv();
    t.channel = 7;
    t.channelDown();


Class TV {

    String color; // 색상
    boolean power; // 전원
    int channel; //채널

    void power() { power = !power;} //전원 제어
    void channelUp() { channel++; } // 채널 증가
    void channelDown() { channel--; } // 채널 감소

```

#### <객체의 생성>

|선언방법|예시|
|:---:|:---:|
|클래스명 변수명;|Tv t;|
|변수명 = new 클래스명();|t = new Tv();|

#### 객체 생성의 간결화

```java

Tv t1 = new Tv(); // 참조 변수에 인스턴스 생성을 한줄로 간결하게 작성할 수 있다


```

******************************************************************************************************************************************************************************************


#### 6.2) 객체배열

* 객체 역시 <b>배열</b>로 다룰 수 있다(참조 변수들을 하나로 묶은 <b>참조 변수 배열</b>이다)

  #### 객체 배열

```java

// Tv tv1, tv2, tv3;
Tv[] tvArr = new Tv[3];

tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// Tv[] tvArr = { new Tv(), new Tv(), new Tv() } 로 간결한 작성 가능

```

******************************************************************************************************************************************************************************************

#### 6.3) 선언위치에 따른 변수의 종류

* 클래스 변수, 인스턴스 변수, 지역 변수가 있다

* 멤버 변수를 제외한 나머지 변수들은 모두 지역 변수, 멤버 변수중 static이 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수이다

#### <선언위치에 따른 변수의 종류 Table>

|변수의 종류|선언 위치|생성시기|
|:---:|:---:|:---:|
|클래스 변수(class variable)|클래스 영역|클래스가 메모리에 올라갈 때|
|인스턴스 변수(instance variable)|클래스 영역|인스턴스가 생성시|
|지역 변수(local variable)|클래스 영역 이외 영역(메서드, 생성자, 초기화 블럭 내부)|변수 선언문이 수행되었을 때|

#### 선언위치에 따른 변수의 종류

```java

class Variables {

    int a;           // 인스턴스 변수
    static int b;    // 클래스 변수

    void method() {
        int a = 0;   // 지역 변수
    }
}

```

******************************************************************************************************************************************************************************************


#### 6.4) 메서드

* 메서드란 특정 작업을 구현하는 문장을 <b>Grouping</b> 한 것이다

* <b>선언부(header)</b>와 <b>구현부(body)</b>로 구성되어 있다

* 변수 타입의 <b>생략은 불가능</b>하다

* return문은 필수요소이다

* 반환 <b>값이 없을 경우</b> 반환타입으로 <b>void</b>를 작성한다(void의 경우 return문 생략이 가능하다, 다만 이는 컴파일러가 자동으로 추가해주기 때문이다)

* Return문의 경우 반환 값이 메서드의 타입과 <b>일치 혹은 자동 형 변환이 가능</b>한 것이여야 한다(자동 형 변환은 작은 범위의 변수에서 같거나 큰 범위의 변수로 전환할 때 가능하다)

* <b>하나의 값</b>만 반환할 수 있다

* 동일 클래스에 소속된 멤버들 간에는 별도 인스턴스 생성 없이 참조 혹은 호출이 가능하다

#### 메서드 작성

```java

class Variables {

int add(int a, int b) {      // 선언부: 반환타입 메서드이름 (타입 변수, 타입 변수)
    int reuslt = a + b;      // 구현부
    return result;           // 구현부

// return a+b; 간결한 표현 가능 

}

```
******************************************************************************************************************************************************************************************

#### 6.5) 참조형 매개변수와 반환

* 매개변수와 반환타입 모두 참조형이 될 수 있다

* 하나의 값만 반환할 수 있다

#### 참조형 매개변수

```java

class Data { int x; }

class Ex {
    public static void main(String[]args) {
        Data d = new Data();
        d.x = 10;

        change(d) // d.x = 1000 값 변경
    }

    static void chnage(Data d) {
        d.x = 1000;
    }
}

```

#### 참조형 반환타입

```java

class Data { int x; }

class Ex {
    public static void main(String[]args) {
        Data d = new Data();
        d.x = 10;

        data d2 = copy(d)

        copy(d) // d.x = 1000 값 변경
    }

    static void copy(Data d) {
        Data tep = new Data(); // 객체 생성
        tmp.x = d.x;
        return tmp;
}

```

******************************************************************************************************************************************************************************************

#### 6.6) static과 인스턴스

* 변수와 메서드 앞에 static이 붙어 있으면 <b>객체를 생성하지 않고도</b> 클래스 이름.메서드 이름(매개변수)로 <b>호출이 가능하다</b>(인스턴스는 <b>반드시 객체를 생성</b>해야 <b>호출이 가능하다</b>)

* 멤버변수 중 모든 인스턴스에 공통으로 사용되는 것에 static을 붙인다

* 클래식 메서드는 인스턴스 변수 및 메서드를 사용할 수 없다

******************************************************************************************************************************************************************************************

#### 6.7) 오버로딩(overloading)

* 메서드 이름이 동일해도, 매개변수의 개수 혹은 타입이 상이하면 같은 이름을 사용해서 메서드를 정의할 수 있다 (반환타입은 상이하여도 오버로딩이 불가하다)

#### 오버로딩

```java

static double add(double a, int b) {
        return a + b;
    }
static double add(int a, double b) {
        return a + b;
    }

```

******************************************************************************************************************************************************************************************

#### 6.8) 생성자(constructor)

* 인스턴스 초기화 메서드로, <b>인스턴스 변수 초기화 작업</b>에 주로 활용된다

* 생성자의 이름은 <b>클래스와 동일</b>해야하며, <b>반환 값은 없다</b>(다만 void는 <b>생략이 가능</b>하다)

* 생성자는 모든 클래스에 필수 요소이나, 클래스 내 생성자가 없을 시 컴파일러가 자동으로 생성한다(생략 가능)

* 클래스이름(타입 변수, 타입 변수) { 인스턴스 변수 초기화 코드}

* this는 동일 클래스 내 다른 생성자를 호출할 때 사용되고, 인스턴스 자신을 가리키는 참조변수로써 활용된다

#### 생성자

```java

Car(String color, String gearType, int door) { // this.변수는 인스턴스 변수, color는 지역변수로 구분된다
    this.color = color;                        // this는 인스턴스 자신을 의미한다
    this.gearType = gearType;
    this.door = door;

Car() {
    this("White", "auto", 4); // Car(String color, String gearType, int door)를 호출
    }
Car(String color){            // Car(String color, String gearType, int door)를 호출
    this(color, "auto", 4)
    }
    
```

******************************************************************************************************************************************************************************************

#### 6.9) 변수의 초기화

* 멤버변수는 자동적으로 기본값으로 초기화가 지원되지만,<b>지역변수는 사용 전 반드시 초기화</b>해야한다

* 클래스 변수의 초기화가 인스턴스 변수의 초기화보다 우선 수행된다

  
#### <선언위치에 따른 변수의 종류 Table>

|자료형|기본값|
|:---:|:---:|
|boolean|false|
|char|'/u0000'|
|byte, short, int|0|
|long|0L|
|float|0.0f|
|double|0.0(0.0d)|
|참조형|null|

******************************************************************************************************************************************************************************************

## 7. 객체지향 프로그래밍 2

### 7-1) 상속

* 기존의 클래스를 <b>재사용</b>하여 <b>새로운 클래스를 작성</b>하는 것이다

* 새로 작성하고자 하는 Child 클래스의 이름 뒤 상속을 의미하는 'extands'와 상속받고자 하는 Parent 클래스의 이름을 함께 작성하여 상속시킨다

* Child 클래스는 Parent 클래스의 모든 멤버를 상속받는다(생성자 및 초기화 제외)

* Child 클래스의 멤버 개수는 Parent 클래스보다 같거나 많을 수 밖에 없다

* <b>단일 클래스</b>로부터의 상속받는 것을 허용한다


#### 상속

```java

class Parent{}
class Child extends Parent

```

#### 상속 예제

```java

    public static void main(String[] args) {
        SmartTv stv = new SmartTv();
        stv.channel = 10;                    // Parent class (Tv)로부터 상속받은 멤버
        stv.channelUp();                     // Parent class (Tv)로부터 상속받은 멤버
        stv.displayCaption("Hello, world");
        stv.caption = true;
        stv.displayCaption("Hello, world");
    }
}

class Tv {
    boolean power;
    int channel;

    void power() { power = !power;}
    void channelUp() { ++channel; }
    void channelDown() { --channel; }
    }

class SmartTv extends Tv {                     // SmartTv는 기존 Tv에 Caption 기능 추가
    boolean caption;
    void displayCaption(String text) {
        if (caption) {
            System.out.println(text);
        }
    }
}

// RESULT:
// Hellow, world

```
******************************************************************************************************************************************************************************************

### 7.2) 포함

* 상속 이외에도 재사용하는 방법이 <b>포함</b>이다, 한 클래스의 멤버변수로 다른 클래스 타입의 <b>참조변수를 선언</b>하는 것이다

* '~는 이다'는 상속관계, '~는 ~를 가지고 있다'는 포함관계로 맺어주는 것이 적절하다

  
#### 상속

```java

class Car {
    Engine E = new engine();
    Door[] d = new Door[4];
    }

```

******************************************************************************************************************************************************************************************

### 7.3) 오버라이딩(overriding)

* Parent 클래스로부터 상속받은 메서드의 내용을 변경하는 것이다

* 동일한 메서드명을 통해 변동된 환경에 맞는 결과를 도출할 수 있다

* 선언부가 Parent 클래스와 일치해야 한다

* 접근 제어자를 Parent 클래스보다 좁은 범위로 변결할 수 없다

* 예외는 Parent 클래스의 메서드보다 많이 선언할 수 없다

#### 상속

```java

  class Point {
        int x, y;
        
        String getLocation() {
            return "x: " + x + ", y: " + y;
        }
    }
    
    class Point3D extends Point {
        int z;
        
        String getLocation() {
            return "x: " + x + ", y" + y + ", z: " + z;

```

******************************************************************************************************************************************************************************************

### 7.4) 참조변수 super

* 상속받은 멤버와 자신의 멤버 이름이 동일할 때, super를 붙여서 구별할 수 있다

* 생성자는 상속되지 않는다

* 클래스 자신에 선언된 변수는 자신의 생성자가 초기화를 책임지도록 작성하는 것이 바람직하다

#### 참조변수 super

```java

 public static void main(String[] args) {
        Child c = new Child();
        c.method();
    }
}
    class Parent {
        int x = 10;                         // super.x
    }

    class Child extends Parent {
        int x = 20;                         // this.x

        void method() {
            System.out.println("x= " + x);
            System.out.println("this.x= " + this.x);
            System.out.println("super.x= " + super.x);
        }
    }

// RESULT:
// x= 20
// thix.x= 20
// super.x= 10

```

#### super() — 조상의 생성자

```java

public static void main(String[] args) {
        Point3D p = new Point3D(1, 2, 3);
        System.out.println("x= " + p.x + ", y= " + p.y + ", z= " + p.z);
    }
}

class Point {
    int x, y;

    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}

class Point3D extends Point {
    int z;

    Point3D(int x, int y, int z) {
        super(x, y);                    // Point(int x, int y)를 호출
        this.z = z;
    }
}

```

******************************************************************************************************************************************************************************************

### 7.5) 패키지(package)

* 클래스의 묶음이다, 관련된 클래스를 그룹 단위로 묶어 효율적으로 관리할 수 있다

* 같은 이름의 클래스도 서로 다른 패키지에 존재하는 것이 가능하다

* 패키지는 하위 패키지를 포함할 수 있다.

* 패키지는 클래스명과 쉽게 구분하기 위해서 소문자로 작성하는 것이 관행이다

* Source 파일에서 주석과 공백을 제외한 첫 번째 문장이여야 한다

#### 패키지 선언

```java
package 패키지명;
```
******************************************************************************************************************************************************************************************

### 7.6) import문

* 다른 패키지의 클래스를 사용하려면 패지키명이 포함된 클래스 이름을 사용해야한다, impor문은 사용하고자 하는 클래스의 패키지를 선제적으로 명시하여 패키지명을 생략시킨다

* 동일 패키지에서 복수의 클래스를 사용할 때, 클래스 이름 대신 '*'을 사용하면 해당 패키지의 모든 클래스를 사용할 수 있다

* static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다

#### import문

```java
import package 패키지명.클래스명;

import 패키지명.*;
```

#### import문 예시

```java
java.util.Date today = new java util.Date(); // import문 선언시: import java.util.Data;
                                           //                  Date today = new Data;                 
```

#### static import문

```java
import static java.lang.Integer.*;   // Integer클래스의 모든 static 메서드
import static java.lang.Math.random; // Math.random()만, 괄호는 생략한다
import static java.lang.System.out;  // System.out을 out만으로 참조가능

System.out.println(Math.random()); // static import문 후 > out.println(random());
```

#### static import문 예시
```java
package Test;

import static java.lang.System.out;
import static java.lang.Math.*;

public class Example {
    public static void main(String[] args) {
      out.println(random());
      out.println("Math.PI: " + PI);
    }
}
```

******************************************************************************************************************************************************************************************

### 7.7) 제어자(Modifier)

* 클래스, 변수 혹은 메서드의 선언부에 함게 사용된다

* 접근제어자와 그 외의 제어자로 분류된다

* 접근제어자: public, protected, (default), private

* 그 외 제어자: static, final, abstract, native, transient, synchronzied, volatile, strictfp

******************************************************************************************************************************************************************************************

### 7.8) static

* static은 '클래스의' 혹은 '공통적인' 의미를 가지고 있다

* static이 사용될 수 있는 곳은 '멤버변수, 메서드, 초기화 블럭'이다


#### <static summary table>

|제어자|대상|의미|
|:---:|:---:|:---:|
|static|멤버변수|모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다 <br/> 클래수 변수는 인스턴스를 생성하지 않아도 사용 가능하다 <br/> 클래스가 메모리에 로드될 때 성생된다|
|static|메서드|인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다 <br/> static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다|

******************************************************************************************************************************************************************************************

### 7.9) final

* final은 '마지막의' 혹은 '변경될 수 없는' 의미를 가지고 있다

* 변수에 사용되면 값을 변경할 수 없는 상수가 된다

* 메서드에 사용하면 오버라이딩이 불가하게 된다

* 클래스에 사용되면 자신을 확장하는 Child 클래스를 정의하지 못하게 된다

* final이 사용될 수 있는 곳은 '클래스, 메서드, 멤버변수, 지역변수'이다

#### <final summary table>

|제어자|대상|의미|
|:---:|:---:|:---:|
|final|클래스|변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다 </br> final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다|
|final|메서드|변경될 수 없는 메서드 </br> final로 지정된 메서드는 오버라이딩을 통해 재 정의 될 수 없다|
|final|멤버변수|변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다|
|final|지역변수|변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다|

******************************************************************************************************************************************************************************************

### 7.10) abstract

* abstract는 '미완성'의 의미를 가지고 있다

* abstract가 사용될 수 있는 곳은 '클래스, 메서드'이다

* 추상 클래스는 말 그대로 미완성을 의미하므로 인스턴스를 생성할 수 없다

#### <abstract summary table>

|제어자|대상|의미|
|:---:|:---:|:---:|
|abstract|클래스|클래스 내에  추상 메서드가 선언되어 있음을 의미한다|
|abstract|메서드|선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다|

******************************************************************************************************************************************************************************************

### 7.11) 접근 제어자(access modifier)

* 외부에서 접근하지 못하도록 제한하는 역할이다

* default는 생략된다, 즉 접근 제어자가 지정되어 있지 않다면 접근 제어자가 default라는 의미이다

* 접근자가 사용될 수 있는 곳은 '클래스, 멤버변수, 메서드, 생성자'이다

* 각 접근 제어자의 접근 범위 크기의 관계는 같다, public > protected > (default) > private

* 외부로부터 데이터를 보호하거나, 외부에는 불필요한 영역을 감추기 위해 사용된다, 이를 캡슐화(encapsulation)이라 한다

* 통상적으로 멤버변수의 값을 읽는 메서드를 'get멤버변수이름'(getter), 멤버변수의 값을 변경하는 메서드의 이름을 'set멤버변수이름'(setter)으로한다

#### <접근 제어자 table>

|접근 제어자|의미
|:---:|:---:|
|private|같은 클래스 내에서만 접근이 가능하다|
|(default)|같은 패키지 내에서만 접근이 가능하다|
|protected|같은 패키지 내에서, 그리고 다른 패캐지의 자손클래스에서 접근이 가능하다|
|public|접근 제한이 전혀 없다|

#### <접근 제어자 접근 범위 table>

|제어자|같은 클래스|같은 패키지|자손 클래스|전   체|
|:---:|:---:|:---:|:---:|:---:|
|public|O|O|O|O|
|protected|O|O|O||
|(default)|O|O||||
|private|O|||||

#### static import문 예시
```java
class Time {
    private int hour, minute, second; // 외부에서 직접 접근하지 못하도록 설정한다

    public int getHour() { return hour;}
    public void setHour(int hour) {
        if (hour < 0 || hour > 23) return;
        this.hour = hour;
    }
    public int getMinute() { return minute;}
    public void getMinute(int minute){
        if (minute < 0 || minute > 59) return;
        this.minute = minute;
    }
    public int getSecond(){return second;}
    public void setSecond() {
        if (second < 0 || second > 59) return;
        this.second = second;
    }
}
```
******************************************************************************************************************************************************************************************

### 7.12) 다형성(polymorphism)

* 여러 가지 형태를 가질 수 있는 능력을 의미한다

* 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 구성되었다

* 같은 타입의 인스턴스지만 참조변수 타입에 따라 사용 할 수 있는 멤버의 개수가 달라진다

* 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 불가능하다(항시 자손타입이 멤버가 더 많기 때문이다)
 
#### static import문 예시
```java
class Tv {
    boolean power;
    int channel;

    void power() {power = !power;}
    void channelUp() { ++channel;}
    void channelDown() {--channel;}
}

class SmartTv extends Tv {
    String text;
    void caption() {}
}

SmartTv s = new SmartTv();    // 참조 변수와 인스턴스의 타입이 일치
Tv t = new SmartTv();         // 조상 타입 참조변수로 자손 타입 인스턴스 참조: Tv 타입의 참조변수 t는 인스턴스가 smartTv이더라도, smartTv의 모든 멤버를 사용할 수 없다
```
******************************************************************************************************************************************************************************************

### 7.13) 참조변수의 형변환

* 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능하다

* 참조형의 형변환은 변수에 저장된 값이 변환되는 것이 아니다,다른 타입으로 변경되는 것이다(사용할 수 있는 멤버의 개수가 변경)

* 상호 상속관계에 있는 타입은 형변환이 자유로이 가능하다

* 참조 변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다 (

#### 참조변수의 형변환

```java
class Car {}
class FireEngine extends Car{}
class Ambulance extends Car{}

FireEngine f = new FireEngine();     
Car c = Car f;                      // OK 생략 가능: Car c= f; | 조상인 Car타입으로 형변환 > 조상타입은 자손타입보다 멤버가 적으므로 생략이 가능하다
FireEngine f2 = (FireEngine)c;      // OK 자손인 FireEngine타입으로 형변환(생략 불가) > 자손타입은 조상타입보다 멤버가 많으므로 생략이 불가하다
ambulance a = (Ambulance)f;         // Error 상손관계가 아니므로 형변환 불가
```
#### 참조변수의 예시
```java
   Car car = null;
    FireEngine fe = new FireEngine();
    FireEngine fe2 = null;

    fe.water();
    car = fe; // car = (Car)fe;에서 형변환이 생략됨
//  car.water(); Car 타입의 참조변수로는 water()를 호출할 수 없다
    fe2 = (FireEngine)car;
    fe2.water();

    }
}
class Car {
    String color;
    int door;

    void drive(){
        System.out.println("drive");
    }
    void stop(){
        System.out.println("stop");
    }
}

class FireEngine extends Car {
    void water() {
        System.out.println("water");
    }
}

// RESULT:
// water
// water

```

******************************************************************************************************************************************************************************************

### 7.14) instanceof 연산자

* 참조변수가 검사한 타입으로 형변환이 가능한지 확인할 수 있다

* 주로 조건문에 사용되며, '참조변수 instanceof 타입(클래스 명)'의 형태로 true와 false중의 하나를 반환한다

* 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다


#### instanceof 연산자 예시  
```java

void doWork(Car c) {
    if (c istanceof FireEngine) {        // 1. 형변환이 가능한지 확인
        Fireengine fe = (FireEngine)c;   // 2. 형변환
        fe.water();

```

******************************************************************************************************************************************************************************************

### 7.15) 매개변수의 다형성

#### 매개변수 다형성 예시
```java
   public static void main(String[] args) {
        Buyer b = new Buyer();

        b.buy(new Tv());
        b.buy(new Computer());
        System.out.println("현재 남은 돈은" + b.money + "만원입니다.");
        System.out.println("현재 보너스 점수는" + b.bonusPoint + "점입니다.");
    }
}

class Product {
    int price;
    int bonusPoint;

    Product(int price) {
        this.price = price;
        bonusPoint = (int)(price/10.0);
    }
}

class Tv extends Product {
    Tv() {
        super(100);}                               // 조상 클래스의 생성자 Product(int price)를 호출한다
    public String toString(){return "Tv";}
}
class Computer extends Product {
    Computer(){super(200);}
    public String toString(){return "Computer";}   // toString()의 오버라이딩
}

class Buyer {
    int money = 1000;
    int bonusPoint = 0;

    void buy(Product p) {
        if(money < p.price) {
            System.out.println("잔액이 부족하여 물건을 살 수 없습니다.");
            return;
        }

        money -= p.price;                          // 조상타임의 참조변수로 자손타입의 객체를 참조하는 것이 가능하다 
        bonusPoint += p.bonusPoint;
        System.out.println(p + "을/를 구매하셨습니다.");
    }
}

*/ Result:
Tv을/를 구매하셨습니다.
Computer을/를 구매하셨습니다.
현재 남은 돈은700만원입니다.
현재 보너스 점수는30만원입니다.
*/
```

#### 매개변수 다형성 객체 배열 예시
```java
    public static void main(String[] args) {
        Buyer2 b = new Buyer2();

        b.buy(new Tv2());
        b.buy(new Computer2());
        b.buy(new Audio2());
        b.summary();
    }
}

class Product2{
    int price;
    int bonusPoint;

    Product2(int price) {
        this.price = price;
        bonusPoint = (int)(price/10.0);
    }
}

class Tv2 extends Product2{
    Tv2(){super(100);}
    public String toString() {return "Tv";}
}

class Computer2 extends Product2 {
    Computer2(){super(200);}
    public String toString() {return "Computer";}
}

class Audio2 extends Product2{
    Audio2(){super(50);}
    public String toString() {return "Audio";}
}

class Buyer2{
    int money = 1000;
    int bonusPoint = 0;
    Product2[] cart = new Product2[10];    // 구입한 제품을 저장하기 위한 배열
    int i = 0;    // Product2 배열에 사용될 Counter

    void buy(Product2 p) {
        if(money < p.price) {
            System.out.println("잔액이 부족하여 물건을 살 수 없습니다.");
            return;
        }
        money -= p.price;
        bonusPoint += p.bonusPoint;
        cart[i++] = p;    // 제품을 Product2[] cart에 저장한다
        System.out.println(p + "을/를 구입하셨습니다.");
    }
    void summary() {
        int sum = 0;
        String itemList ="";

        for (int i = 0; i < cart.length; i++) {
            if(cart[i]==null) break;
            sum += cart[i].price;
            itemList += (i==0) ? "" + cart[i] : ", " + cart[i];
        }
        System.out.println("구입하신 물품의 총금액은 " + sum + "만원입니다.");
        System.out.println("구입하신 제품은 " + itemList + "입니다.");
    }
}

*/ Result:
Tv을/를 구입하셨습니다.
Computer을/를 구입하셨습니다.
Audio을/를 구입하셨습니다.
구입하신 물품의 총금액은 350만원입니다.
구입하신 제품은 Tv, Computer, Audio입니다.
*/

```

******************************************************************************************************************************************************************************************

### 7.16) 추상 클래스(abstract class)

* 클래스가 설계도라면, 추상 클래스는 미완성 설계도로 비유할 수 있다

* 맴버의 개수에 관계된 것이 아닌, 미완성 메서드를 포함하고 있다는 의미이다

* 추상 클래스는 인스턴스를 생성할 수 없다, 상속을 통해 자손 클래스에 의해서만 완성된다

* 추상 클래스는 클래스 이름 앞에 'abstract'를 붙이기만 하면 된다

#### 추상 클래스 사용 방법

```java

abstract class 클래스이름{
    ...
}

```
******************************************************************************************************************************************************************************************

### 7.17) 추상 메서드(abstarct method)

* 추상 메서드는 선언부만 작성하고 구현부는 작성하지 않은채 구성된 메서드이다

* 상속받는 클래스에 따라 메서드의 내용이 달라질 수 있기 때문에, 조상 클래스에서는 선언부만을 작성하고 주석을 덧붙여 어떤 기능을 수행할 목적인지 작성하여 활용할 수 있다

* 추상메서드 역시 'abstract'를 앞에 붙여 사용한다

* 추상클래스로부터 상속받는 자손 클래스는 오버라이딩을 통해 조상인 추상클래스의 추상 메서드를 모두 구현해주어야 한다

#### 추상 메서드 사용 방법

```java

abstract 리턴타입 메서드이름(); // 해당 메서드의 취지를 작성한다

```
#### 추상 메서드 사용 예시

```java

abstract class Player {                // 추상 클래스
        abstract void play(int pos);   // 추상 메서드
        abstract void stop();          // 추상 메서드
}

class AudioPlayer extends Player {
       void play(int pos){}            // 추상 메서드 구현
        void stop(){}                  // 추상 메서드 구현
}

```
#### 추상 메서드 사용 예시

```java
abstract class Unit{
    int x, y;

    abstract void move(int x, int y);
    void stop(){/* 현재 위치에 정지 */}
}

class Marine extends Unit{*/}
}

class Tank extends Unit{
    void move(int x,int y) {/* 지정된 위치로 이동 */}
    void changeMode(){/* 공격모드를 변환한다 */}
}

class DropShip extends Unit{
    void move(int x,int y) {/* 지정된 위치로 이동 */}
    void load(){/* 선택 대상을 태운다 */}
    void unload(){/* 선택 대상을 내린다 */}
}


```

******************************************************************************************************************************************************************************************

### 7.18) 인터페이스(interface)

* 추상클래스 처럼 몸통을 갖춘 일반 메서드 혹은 멤버 변수를 구성원으로 가질 수 없다

* 추상 메서드와 상수만을 멤버로 가질 수 있다

* 모든 멤버 변수는 public static final, 모든 메서드는 public abstract 이어야 하며 이를 생략할 수 있다

* 인터페이스는 인터페이스로부터만 상속받을 수 있다, 다중상속이 가능하다

* 추상클래스와 마찬가지로 인스턴스를 생성할 수 없으며, 'extends' 대신 'implements'를 활용하여 메서드를 정의하며 interface의 구현이라고 표현한다

* 활용 시 개발시간 단축 및 표준화 가능, 서로 관계 없는 클래스들의 관계 맺음, 독립적인 프로그래밍가능 등의 장점이 있다


#### interface 작성

```java
interface 인터페이스 이름 {
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수);
}
```

#### interface 상속

```java
interface Moveable {
    void move(int x, int y);
    }

interface Attackable {
    void attack(Unit u);
    }
interface Fightable extends Movable, Attackable {}

```
#### interface 구현

```java
class 클래스 이름 implements 인터페이스 이름{
    // interface의 모든 추상 메서드 구현
}
class Fighter implements fightable {
    public void move(int x, int y) { }
    public void attack(Unit u) { }
}
```

#### 구현하는 인터페이스 메서드 중 일부만 구현한다면, abstract를 붙여 추상클래스를 선언해야한다
```java
abstract class Fihgter implements Fightable {
    public void move(int x, int y) { }
}
```

#### 상속과 구현의 동시 수행
```java
class Fighter extends Unit implements Fightable {
    public void move(int x, int y) { }
    public void attack(Unit u) { }
}
```

#### 인터페이스를 구현한 클래스의 인스턴스를 참조할 수 있다 (또한 매개 변수 타입, 리턴타입으로 활용될 수 있다)
```java
Fightable f = (Fightable)new Fighter();
Fightable f = new Fighter();
```

******************************************************************************************************************************************************************************************

### 7.19) 디폴트 메서드와 static 메서드

* 인터페이스의 경우 메서드를 추가하게되면, 이를 구현한 기존 모든 클래스들이 새로 추가도니 메서드를 구핸해야한다, 이러한 경우 static 혹은 default method를 활용하여 효율적인 코드를 작성할 수 있다

* default method는 접근 제어자가 public이며, 생략이 가능하다

* 디폴트 메서드와 조상 클래스의 메서드간의 이름 중복 시, 조상 클래스의 메서드가 상속되고 디폴트 메서드는 무시된다

* 여러 인터페이스의 디폴트 메서드 간의 충돌 시, 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다

  ******************************************************************************************************************************************************************************************

  ### 7.20) 내부 클래스(inner class)

  * 내부 클래스는 클래스 내에 선언된 클래스이다
 
  * abstract, 접근 제어자의 사용 또한 가능하다
 
 
  
 #### 내부 클래스의 종류와 특징
 
|내부 클래스|특징|
|:---:|:---:|
|인스턴스 클래스(instance class)|외부 클래스의 멤버변수 선언위치에 선언, 외부 클래스의 인스턴스멤버처럼 다루어진다, 주로 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언|
|스태틱 클래스(static class|외부 클래스의 멤버변수 선언위치에 선언, 외부 클래스의 static멤버처럼 다루어진다, 주로 외부 클래스의 static 멤버, 특히 static메서드에서 사용 할 목적으로 선언|
|지역 클래스(local class)|외부 클래스의 메서드나 초기화블럭 내에 선언, 선언된 영역 내부에서만 사용될 수 있다|
|익명 클래스(anonymous class)|클래스의 선언과 객체의 생성을 동시에 하는 이름 없는 클래스(일회용)| 


#### 내부 클래스 예시
```java
class Outer {
    private class InstacneInner{ }
    protected static class StaticInner { }

    void myMethod(){} {
        class LocalInner{}
    }
}

******************************************************************************************************************************************************************************************

### 7.21) 익명 클래스(anonymous class)

* 별도의 이름이 없으며 클래스의 선언과 객체의 생성을 동시에 하기에 오직 하나만의 객체만을 생성할 수 있는 일회용 클래스이다

* 이름이 없기에 생성자도 가질 수 없으며, 조상 클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의한다

* 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만 구현할 수 있다

#### 익명 클래스
```java
new 조상클래스 이름() {
// 멤버 선언
}

new 구현인터페이스이름() {
// 멤버 선언
}
```

#### 익명 클래스 사용 전
```java
class Example {
    public static void main(String[]args) {
        Button b = new Button("Start");
        b.addActionListener(new EventHandler());
    }
}
class EventHandler implements ActionListener {
    public void actionPerformed(ActionEvent e) {
        System.out.println("ActionEvent occurred!!!");
        }
}
```

#### 익명 클래스 사용 후
```java
class Example {
    public static void main(String[]args) {
        Button b = new Button("Start");
        b.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent e){
                System.out.println("ActionEvent occurred!!!");
            }
        }
        )
    }
}
```

******************************************************************************************************************************************************************************************

## 8. 예외처리 (exception handling)

### 8.1) 프로그램 오류

* 컴파일 에러: 컴파일 시 발생하는 에러

* 런타임 에러: 실행 시 발생하는 에러

* 논리적 에러: 실행은 되나, 의도와 다르게 작동하는 것

* 에러(error): 프로그램 코드에 의해서 수습될 수 없는 심각한 오류

* 예외(exception): 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류

******************************************************************************************************************************************************************************************

### 8.2) Exception & RuntimeException

* Java에서는 오류(exception과 error)를 클래스로 정의하였다

* Exception 클래스: 사용자의 실수와 같은 외적인 요인에 의하 밸상하는 예외

* RuntimeException 클래스: 프로그래머의 실수로 발생하는 예외

* Exception 발생 시 예외 처리를 해주지 않으면 컴파일이 수행되지 않는다, 반면 RuntimeException은 예외 처리 없이 컴파일이 수행 가능하다(RuntimeException은 프로그래머 실수로 발생하기에 예외 처리를 강제하지 않는다)
 ******************************************************************************************************************************************************************************************

### 8.3) 예외 처리하기 try - catch 문

* 예외 처리란 프로그램 실행 시 발생할 수 있는 예기치 못한 예외 발생에 대비한 코드이다

* 발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료된다

* 하나의 try 블럭 다음에는 어려 종류의 예외를 처리할 수 있도록 하나 이상의 catch 블럭이 올 수 있다

* 발생한 예외의 종류와 일치하는 단 한 개의 catch 블럭만 수행되며, 발생한 예외의 종류와 일치하는 catch 블럭이 없으면 예외는 처리되지 않는다

* catch 블럭 수행 후 전체 try - catch 문을 빠져나가 그 다음 문장을 수행한다

* 여러 catch 블럭을 '|' 기호를 이용하여 하나의 catch 블럭으로 합칠 수 있다, 이를 '멀티 catch 블럭'이라 한다

* catch 블럭의 '|'로 연결된 예외 클래스가 조상과 자손의 관계라면 컴파일 에러가 발생한다

#### try - catch 문

```java

try {
    // 예외가 발생할 가능성이 있는 문장 작성
} catch (Exception e1) {
    // Exception e1이 발생했을 경우, 이를 처리하기 위한 문장 작성
} catch (Exception e2)
    // Exception e2가 발생했을 경우, 이를 처리하기 위한 문작 작성
}

```

#### try - catch 문 catch 블럭 미 실행 예시

```java

    public static void main(String[] args) {
        System.out.println(1);
        try {
            System.out.println(2);
            System.out.println(3);
        } catch (Exception e) {
            System.out.println(4); // 실행되지 않는다
        } // try - catch 문의 끝
        System.out.println(5);
    }

*/ Result:
1
2
3
5
*/

```

#### try - catch 문 catch 블럭 실행 예시

```java

    public static void main(String[] args) {
        System.out.println(1);
        try {
            System.out.println(0/0); // 고의로 Exception 발생
            System.out.println(2); // 실행되지 않는다
        } catch (ArithmeticException ae) {
            System.out.println(3);
        } // try - catch 문의 끝
        System.out.println(4);
    }

*/ Result:
1
3
4
*/

```
******************************************************************************************************************************************************************************************

### 8.4) 예외의 발생과 catch 블럭

* catch 블럭의 괄호 내에는 예외와 같은 타입의 참조변수 하나를 선언해야한다

* 예외가 발생하면, 예외에 해당하는 클래스의 인스턴스가 만들어진다, 또한 instanceof 연산자를 통해 ture 값을 반환하는 catch 블럭을 탐색한다

* 모든 예외 클래스는 Exception 클래스의 자손이므로, catch 블럭의 괄호에 Exceiption 클래스 타입의 참조변수를 선언하면 어떠한 경우에도 해당 catch 블럭에 의해 처리된다


#### exception 클래스 예시
```java

public class Test1 {
    public static void main(String[] args) {
        System.out.println(1);
        try {
            System.out.println(0/0); // 고의로 ArithmeticException 발생
            System.out.println(2); // 실행되지 않는다
        } catch (Exception ae) { // ArithmeticException 대신 조상 클래스 Exception 사용
             System.out.println(3);
        } // try - catch 문의 끝
        System.out.println(4);
    }

```

******************************************************************************************************************************************************************************************

### 8.5) printStackTrace()와 getMessage()

* printStackTrace(): 예외 발생 당시의 Call Stack에 있었던 메서드의 정보와 예외 메세지를 화면에 출력한다

* getMessage(): 발생한 예외 클래스의 인스턴스에 저장된 메세지를 얻을 수 있다

* Exceiption 인스턴스 생성시, 생성자에 String을 넣어 주면 인스턴스에 메세지로 저장되어 getMessage()를 이용해 얻을 수 있다

  
#### printStackTrace() & getMessage() 예시
```java
    public static void main(String[] args) {
        System.out.println(1);
        System.out.println(2);
        try {
            System.out.println(3);
            System.out.println(0/0); // 예외 고의 발생
            System.out.println(4); // 실행되지 않는다
        } catch (Exception ae) {
            ae.printStackTrace();
            System.out.println("예외메시지: " + ae.getMessage());
        } // try - catch 문의 끝
        System.out.println(6);
    }

*/ Result:
1
2
3
예외메시지: / by zero
6
java.lang.ArithmeticException: / by zero
	at test.Test1.main(Test1.java:9)
*/

```

******************************************************************************************************************************************************************************************

### 8.6) 예외 발생시키기

* 키워드 thorw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다


```java

    public static void main(String[] args) {
        try {
            Exception e = new Exception("고의 발생");  // 생성자에 String을 넣어 인스턴스에 메세지를 저장
            throw e;                                 // throw new Exception("고의 발생")으로 생략 가능
        } catch (Exception e) {
            System.out.println("에러 메세지: " + e.getMessage());
            e.printStackTrace();
        }
        System.out.println("프로그램이 정상 종료되었습니다");
    }

*/ Result:
에러 메세지: 고의 발생
프로그램이 정상 종료되었습니다
java.lang.Exception: 고의 발생
	at test.Test1.main(Test1.java:6)
*/

```

******************************************************************************************************************************************************************************************

### 8.7) 메서드에 예외 선언

* 예외를 처리하는 방법중 하나이다(다만 직접 처리하는 것이 아닌 이송을 수행한다)

* 메서드의 선언부에 키워드 throws를 사용해서 작성한다, 여려 개의 예외일 경우 ','로 구분한다

* 예외 선언 시, 자손타입의 예외까지도 발생할 수 있다

* 예외가 선언되어 있으면 Exception과 같은 checked 예외를 try - catch 문으로 처리하지 않아도 컴파일 에러가 발생하지 않는다

#### 메서드의 예외 선언
```java

void method() throws Exception1, Exception2 { ... }

```

#### 메서드 예외 선언 예시



```java
public class Test1 {
    public static void main(String[] args) throws Exception {
        method1();
    }
    static void method1() throws Exception {
        method2();
    }
    static void method2() throws Exception {
        throw new Exception();
    }
}
/* Result:
Exception in thread "main" java.lang.Exception
	at test.Test1.method2(Test1.java:11)
	at test.Test1.method1(Test1.java:8)
	at test.Test1.main(Test1.java:5)
*/
```

******************************************************************************************************************************************************************************************

### 8.8) finally 블럭

* finally 블럭은 예외의 발생 여부에 상관 없이 실행되어야 할 코드를 포함시킬 목적으로 사용된다

* try - catch (- finally)의 순서로 구성되며 선택적으로 사용할 수 있다

#### finally 사용
```java

try {
	// 예외가 발생할 가능성이 있는 문장 작성
} catch (Exception1 e1) {
	// 예외를 처리하기 위한 문장 작성
} finally {
	// 예외 발생 여부와 관계 없이 항시 수행될 문장 작성
}

```

#### finally 예시
```java

try {
	strartInstall();	// 프로그램 설치에 필요한 준비를 한다
	copyFiles();		// 파일들을 복사한다
} catch (Exception e) {
	e.printStackTrace();
} finally {
	deleteTempFiles();	// 프로그램 설치에 사용된 임시파일들을 삭제한다
}
```
******************************************************************************************************************************************************************************************

### 8.9) 사용자 정의 예외

* 통상저으로 Exception 혹은 RuntimeException 클래스로부터 상속받는 클래스를 만든다

#### 사용자 정의 예외
```java

class MyException extends Exception {
	MyException(String msg) { // 문자열을 매개변수로 받는 생성자
		super(msg); // 조상인 Exception클래스의 생성자를 호출한다

```

#### 사용자 정의 예외 예시
```java
public class Test1 {
    public static void main(String[] args) {
        try {
            startInstall(); // 프로그램 설치에 필요한 준비
            copyFiles();    // 파일 복사
        } catch (SpaceException e) {
            System.out.println("에러 메세지: " + e.getMessage());
            e.printStackTrace();
            System.out.println("공간을 확보한 후에 다시 시도해주시기 바랍니다.");
        } catch(MemoryException me) {
            System.out.println("에러 메세지: " + me.getMessage());
            me.printStackTrace();
            System.gc();    //Garbage Collection을 수행하여 메모리 확보
            System.out.println("다시 설치를 시도하세요.");
        } finally {
            deletedTempFiles(); // 프로그램 설치에 사용된 임시파일 삭제
        } // try 끝
    } // main 끝
    static void startInstall() throws SpaceException, MemoryException {
        if (!enoughSpace()) {
            throw new SpaceException("설치항 공간이 부족합니다.");
        }
        if (!enoughMemory()) {
            throw new MemoryException("메모리가 부족합니다.");
        }
    } //startInstall 메서드 끝

    static void copyFiles(){/*파일 복사 코드*/}
    static void deletedTempFiles(){/*임시 파일 삭제 코드*/}

    static boolean enoughSpace(){/*설치 요구 공간 확인 코드*/}
    static boolean enoughMemory(){/*설치 요구 메모리 공간 확인 코드*/}
}

class SpaceException extends Exception {
    SpaceException(String msg) {
        super(msg);
    }
}
class MemoryException extends Exception {
    MemoryException(String msg) {
        super(msg);
    }
}

```

******************************************************************************************************************************************************************************************

### 8.10) 예외 되던지기(exception re-throwing)

* 예외가 여럿인 경우, 몇 개는 try - catch문을 통해서 메서드 내부적으로 처리하고, 그 나머지는 선언부에 작성하여 호출한 메서드에서 처리되도록 할 수 있다

* 단 하나의 예외에 대해서도 예외 발생 메서드, 호출한 메서드, 양 쪽에서 처리하도록 할 수 있다

* 예외를 처리한 후 인위적으로 다시 발생시키는데 이를 '예외 되던지기'라고 한다


#### 예외 되던지기 예시
```java
    public static void main(String[] args) {
        try {
            method1();
        } catch (Exception e) {
            System.out.println("main메서드에서 예외가 처리되었습니다.");
        }
    } // main 메서드 종료
    static void method1() throws Exception {
        try {
            throw new Exception();
        } catch (Exception e) {
            System.out.println("method1에서 예외가 처리되었습니다");
            throw e;
        }
    } // method1 메서드 종료

/* Result:
method1에서 예외가 처리되었습니다
main메서드에서 예외가 처리되었습니다.
*/
```

******************************************************************************************************************************************************************************************

### 8.11) 연결된 예외(chained exception)

* 한 예외가 다른 예외를 발생시킬 수 있으며 예외 A가 예외 B를 발생시켰다면 A를 B의 '원인 예외(cause exception)'라 한다

* Throwable initCuase(Throwable cuase): 지정한 예외를 원인 예외로 등록

* Throwable geCuase(): 원인 예외를 반환

* RuntimeException(Throwable cause): 원인 예외를 드록하는 생성자

* initCause()는 Exception 클래스의 조상인 Throwable 클래스에 정의되어 있어 모든 예외이서 사용 가능하다

* 여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위함이다

* checked 예외를 unchecked 예외로 변경할 수 있다

#### 연결된 예외 예시
```java
try {
	startInstall();
 	copyFiles();
} catch (SpaceException e) {
	InstallException ie = new InstallException("설치중 예외 발생"); // 예외 생성
	ie.initCuase(e); // InstallException의 원인 예외를 SapceException으로 지정
	throw ie; // InstallException을 발생시킨다
} catch (MemoryException me) { ...
}
```

******************************************************************************************************************************************************************************************

## 9) java.lang패키지와 유용한 클래스


### 9.1) Object 클래스

* java.lang 패키지는 import문 없이 사용할 수 있다

* Object 클래스는 모든 클래스의 최고 조상이기에 Object 클래스의 멤버들은 모든 클래스에서 사용 가능하다

#### <Object 클래스 Table>
|Object 클래스의 메서드|설명|
|:---:|:---:|
|protected Object clone()|객체 자신의 복사본 반환|
|public boolean equals(Object obj)|객체 자신과 객체 obj가 같은 객체인지 알려준다(true)|
|protected void finalize()|객체가 소멸될 대 가비지 컬렉터에 의해 자동적으로 호출된다, 이 때 수행되어야 하는 코드가 있을 때 오버라이딩한다|
|public Class getClass()|객체 자신의 클래스 정보를 담고 있는 Class인스턴스를 반환한다|
|public int hashcode()|객체 자신의 해시코드를 반환한다|
|public String toString|객체 자신의 정보를 문자열로 반환한다|
|public void notify()|객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨운다|
|public void notifyAll()|객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨운다|
|public void wait<br>  public void wait(long timeout)<br> public void wait(long timeout, int nanois)|다른 쓰레드가 notify() 혹은 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간(timeout, nanos)동안 기다리게 한다(timeout은 천 분의 1초, nanos는 10^9분의 1초)


******************************************************************************************************************************************************************************************

### 9.2) Object 클래스 - equals()

* 매개변수로 객체의 참조변수를 받아 그 결과를 bollean 값으로 알려주는 기능을 한다

* 참조변수 외 Value 값을 비교하도록 하기 위해선 오버라이딩 과정이 필요하다

#### equals()
```java
public boolean equals(Object obj) {
	return (this==obj);
```

#### equals() 에시

```java

    public static void main(String[] args) {
        Value v1 = new Value(10);
        Value v2 = new Value(10);

        if (v1.equals(v2)) {
            System.out.println("v1과 v2는 같습니다.");
        } else {
            System.out.println("v1과 v2는 다릅니다.");
        }
    }
}

class Value {
    int value;

    Value(int value) {
        this.value = value;
    }
}
/*
Result:
v1과 v2는 다릅니다.
*/

```

#### equals() 오버라이딩 예시

```java
    public static void main(String[] args) {
        Person p1 = new Person(80110811121L);
        Person p2 = new Person(80110811121L);

        if (p1.equlas(p2)) {
            System.out.println("p1과 p2는 같습니다.");
        } else {
            System.out.println("p1과 p2는 다릅니다.");
        }
    }

}

class Person {
    long id;

    public boolean equlas(Object obj) {
        if (obj instanceof Person) {
            return id == ((Person) obj).id;
        } else {
            return false;
            }
    }
    Person(long id) {
        this.id = id;
    }
}

/*
Result:
p1과 p2는 같습니다.
*/
```

******************************************************************************************************************************************************************************************

### 9.3) Object 클래스의 메서드 - hashCode()

* 해시함수는 찾고자하는 값 입력시, 그 값의 지정된 위치를 알려주는 해시코드(hashcode)를 반환한다

* 해시코드가 같은 두 객체가 존재하는 것은 가능하나, Object 클래스에 정의된 hashCode 메서드는 객체의 주소값을 이ㅛㅇ해서 반환하기에 서로 다른 객체는 동일한 해시코드를 가질 수 없다

* String 클래스는 문자열의 내용이 같으면 동일한 해시코드를 반환하도록 hashCode()가 오버라이딩 되어 있다

* System.identifyHashCode는 Object 클래스의 hashCode 메서드처럼 객체의 주소 값으로 hashcode를 생성하기에 모든 객체에 대해 항상 다른 값을 반환한다


#### hashCode() 예시

```java

    public static void main(String[] args) {
        String str1 = new String("abc");
        String str2 = new String("abc");
        String str3 = "abc";

        System.out.println(str1.equals(str2));
        System.out.println(str1.hashCode());
        System.out.println(str2.hashCode());
        System.out.println(str3.hashCode());
        System.out.println(System.identityHashCode(str1));
        System.out.println(System.identityHashCode(str2));
        System.out.println(System.identityHashCode(str3));

/*
Result:
true
96354
96354
96354
189568618
793589513
1313922862
*/

```
******************************************************************************************************************************************************************************************

### 9.4) Object 클래스의 메서드 - toString()

* toString 메서드는 인스턴스에 대한 정보를 문자열(String)로 제공하는 기능을 한다

* toString()을 호출하면 클래스 이름과 16진수의 해시코드를 반환한다

* String 클래스의 toString()은 인스턴스의 문자열을, Data 클래스의 경우 날짜와 시간을 문자열로 반환하도록 오버라이딩 되어 있다

* toString()은 일반적으로 인스턴스나 클래스에 대한 정보 또는 인스턴스 변수들의 값을 문자열로 반환하도록 오버라이딩된다

#### toString()

```java
public String toString(){
	return getClass().getName()+"@"+Integer.toHexString(hashCode());
}
```

#### toString() 예시

```java

    public static void main(String[] args) {
        Card c1 = new Card();
        Card c2 = new Card();

        System.out.println(c1.toString());
        System.out.println(c2.toString());
    }
}

class Card {
    String kind;
    int number;
    Card() {
        this("SPADE", 1);
    }
    Card(String kind, int number) {
        this.kind = kind;
        this.number = number;
    }
}

/*
Result:
Card@2f4d3709
Card@4e50df2e
*/

```

#### toString() 오버라이딩 예시

```java

    public static void main(String[] args) {
        Card c1 = new Card();
        Card c2 = new Card("HEART", 10);

        System.out.println(c1.toString());
        System.out.println(c2.toString());
    }
}

class Card {
    String kind;
    int number;
    Card() {
        this("SPADE", 1);
    }
    Card(String kind, int number) {
        this.kind = kind;
        this.number = number;
    }
    public String toString() { 				// Parent 클래스에 정의된 메서드를 Child 클래스에서 오버라이딩 할 때, Parent에 정의된 접근범위와 같거나 더 넓어야 한다
        return "kind : " + kind + ", number: " + number;
    }
}

/*
Result:
kind : SPADE, number: 1
kind : HEART, number: 10
*/

```

******************************************************************************************************************************************************************************************

### 9.5) String 클래스

* String 클래스는 java에서 char형의 문자를 문자열로 다루기 위해 제공하는 클래스이다

* String 클래스에는 문자열을 저장하기 위해 문자형 배열 참조변수 'char[]' value를 인스턴스 변수로 정의해놓고 있다

* 한 번 생성된 String 인스턴스가 지닌 문자열은 변경이 불가하다, '+' 연산자를 통해 String 인스턴스 변경시 인스턴트 내 문자열 변경이 아닌 새로운 문자열을 담는 String 인스턴스가 생성되는 것이다

* 따라서 '+' 연산자를 통한 문자열 결합은 메모리 공간을 차지하게 되므로 지양하는 것이 메모리 공간 확보 목적으로 적절하다

* 문자간 결합이나 추출 등의 작업이 많이 요구도리 경우 StringBuffer 클래스를 사용하는 것이 적절하다
  
* 길이가 0인 배열은 존재할 수 있으며 'String s ="";'과 같은 문장이 있을 때, 참조 변수 s가 참조하고 있는 String 인스턴스 내부에 'new chhar[0]'과 같이 길이가 0인 char형 배열을 저장하고 있다

#### String 클래스

```java

public final class String implements java.io.Serializable, Comparable {
	private char[] value;
}
```

#### String 클래스의 비교

* 동일 내용의 문자열 리터럴은 이미 존재하는 것을 재사용하는 것이다 (따라서 str1과 str2가 반환하는 주소는 동일하다)


```java

    public static void main(String[] args) {
        String str1 = "abc";	// 문자열 리터럴 "abc"의 주소가 str1에 저장됨			
        String str2 = "abc";	// 문자열 리터럴 "abc"의 주소가 str2에 저장됨			
        System.out.println("String str1 = \"abc\";");
        System.out.println("String str2 = \"abc\";");

        System.out.println("str1 == str2 ? " + (str1 == str2));
        System.out.println("str1.equals(str2) ?" + str1.equals(str2));
        System.out.println();

        String str3 = new String("abc");	// 새로운 String 인스턴스를 생성
        String str4 = new String("abc");	// 새로운 String 인스턴스를 생성

        System.out.println("String str3 = \"abc\";");
        System.out.println("String str4 = \"abc\";");

        System.out.println("str3 == str4 ? " + (str3 == str4));
        System.out.println("str3.equals(str4) ?" + str3.equals(str4));
    }
}

/*
Result:
String str1 = "abc";
String str2 = "abc";
str1 == str2 ? true
str1.equals(str2) ?true

String str3 = "abc";
String str4 = "abc";
str3 == str4 ? false
str3.equals(str4) ?true
*/
```

******************************************************************************************************************************************************************************************

### 9.6) String 클래스의 생성자와 메서드

#### <String 클래스의 생성자 및 메서드 Table>
|메서드|설명|
|:---:|:---:|
|String(String s)|주어진 문자열(s)을 갖는 String인스턴스를 생성한다|
|String(char[] value)|주어진 문자열(value)을 갖는 String 인스턴스를 생성한다|
|String(StringBuffer buf)|StringBuffer 인스턴스가 갖고 있는 문자열과 같은 내용의 String 인스턴스를 생성한다|
|char charAt(int index)|지정된 위치(index)에 있는 문자를 알려준다(index는 0부터 시작)|
|int compareTo(String str)|문자열(str)과 사전순서로 비교한다. 같으면 0을, 사전순으로 이전이면 음수, 이후면 양수를 반환한다|
|String concat(String str)|문자열(str)을 뒤에 덧붙인다|
|boolean contrains(CharSequence s)|지정된 문자열(s)이 포함되어있는지 검사한다|
|boolean endsWith(String suffix)|지정된 문자열(suffix)로 끝나는지 검사한다|
|boolean equals(Object obj)|매개변수로 받은 문자열(obj)과 String 인스턴스의 문자열을 비교한다, obj가 String이 아니거나 문자열이 다르면 false를 반환한다|
|boolean equalsIgnoreCase(String str)|문자열과 String 인스턴스의 문자열을 대소문자 구분없이 비교한다|
|int indexOf(int ch)|주어진 문자(ch)가 문자열에 존재하는지 확인하여 위치(index)를 알려준다, 못 찾으면 -1을 반환한다(index는 0부터 시작)|
|int indexOf(int ch, int pos)|주어진 문자(ch)가 문자열에 존재하는지 지정된 위치(pos)부터 확인하여 위치(index)를 알려준다, 못 찾으면 -1을 반환한다(index는 0부터 시작)|
|int indexOf(String str)|주어진 문자열이 존재하는지 확인하여 그 위치(index)를 알려준다, 없으면 -1을 반환한다(index는 0부터 시작)|
|String intern()|문자열을 상수풀(constant pool)에 등록한다, 이미 상수풀에 같은 내용의 문자열이 있을 경우 그 문자열의 주소값을 반환한다|
|int lastIndexOf(int ch)|지정된 문자 혹은 인스턴스의 문자열 끝에서부터 찾아서 위치(index)를 알려준다, 못 찾으면 -1을 반환한다|
|int length()|문자열의 길이를 알려준다|
|String replace(char old, char nw)|문자열 중의 문자(old)를 새로운 문자(nw)로 바꾼 문자열을 반환한다|
|String replaceAll(String regex, String replacement)|문자열 중에서 지정된 문자열(regex)과 일치하는 것을 새로운 문자열(replacement)로 모두 변경한다|
|String replaceFirst(String regex, String replacement|문자열 중에서 지정된 문자열(regex)과 일치하는 것 중, 첫 번째 것만 새로운 문자열(replacement)로 변경한다|
|String[] split(String regex)|문자열을 지정된 분리자(regex)로 나누어 문자열 배열에 담아 반환한다|
|String[] splic(String regex, int limit)|문자열을 지정된 분리자(regex)로 나누어 문자배열에 담아 반환한다, 단 문자열 전체를 지정된 수(limit)로 자른다|
|boolean startWith(String prefix)|주어진 문자열(prefix)로 시작하는지 검사한다|
|String substring(int begin) <br> String substring(int begin, int end)|주어진 시작위치(begin)부터 끝 위치(end)범위에 포함된 문자열을 얻는다, 이 때 시작위치의 문자는 범위에 포함되지만 끝 위치의 문자는 포함되지 않는다|
|String toLowerCase()|String 인스턴스에 저장되어 있는 모든 문자열을 소문자로 변환하여 반환한다|
|String toString()|String 인스턴스에 저장되어 있는 문자열을 반환한다|
|String toUpperCase()|String 인스턴스에 저장되어 있는 모든 문자열을 대문자로 변환하여 반환한다|
|String trim()|문자열의 왼쪽 끝과 오른쪽 끝에 있는 공백을 없앤 결과를 반환한다, 이 때 문자열 중간에 있는 공백은 제거되지 않는다|
|static String valueOf(boolean b) <br> static String valueOf(char c) <br> static String valueOf(int i) <br> static String valueOf(long l) <br> static String valueOf(float f) <br> static String valueOf(double d) <br> static String valueOf(Object o)|지정된 값을 문자열로 변환하여 반환한다, 참조변수의 경우 toString()을 호출한 결과를 반환한다|

******************************************************************************************************************************************************************************************

### 9.7) String 클래스의 생성자와 메서드

* join은 여러 문자열 사이에 구분자를 넣어서 결합하는 기능을 한다

* java.util.StringJoiner 클래스를 사용해서 문자열을 결합할 수도 있다

#### join() 및 Stringjoiner 예시

```java
import java.util.StringJoiner;

    public static void main(String[] args) {
        String animals = "dog,cat,bear";
        String[] arr = animals.split(",");

        System.out.println(String.join("-",arr));

        StringJoiner sj = new StringJoiner("/", "[", "]");
        for(String s : arr)
            sj.add(s);

        System.out.println(sj.toString());

*/
Result:
dog-cat-bear
[dog/cat/bear]
/*

```

******************************************************************************************************************************************************************************************

### 9.8) 문자열과 기본형 간의 변환

* 기존에 parseInt()와 같은 메서드는 이름을 통일하기 위해 valueOf()가 추가되었다

#### <문자열 및 기본형 변환 Table>

|기본형 → 문자열|문자열 → 기본형|
|:---:|:---:|
|String Strin.valueOf(boolean b) <br> String Strin.valueOf(char c) <br> String Strin.valueOf(int i) <br> String Strin.valueOf(long l) <br> String Strin.valueOf(float f) <br> String Strin.valueOf(double d)|boolean Boolean.parseBoolean(String s) <br> byte Byte.parseByte(String s) <br> short Short.parseShort(String s) <br> int Integer.parseInt(String s) <br> long Log.paseLong(String s) <br> float Float.parseFloat(String s) <br> double double.parseDouble(String s)|

#### 문자열 및 기본형 변환 예시

```java

    public static void main(String[] args) {
        int iVal = 100;
        String strVal = String.valueOf(iVal); // int를 String으로 변환한다

        double dVal = 200.0;
        String strVal2 = dVal + ""; // int를 String으로 변환하는 또 다른 방법

        double sum = Integer.parseInt("+" + strVal) + Double.parseDouble(strVal2);
        double sum2 = Integer.valueOf(strVal) + Double.valueOf(strVal2);

        System.out.println(String.join("",strVal, "+",strVal2,"=")+sum);
        System.out.println(strVal+"+"+strVal2+"="+sum2);

/*
Result:
100+200.0=300.0
100+200.0=300.0
/*
```

******************************************************************************************************************************************************************************************

### 9.9) StringBuffer 클래스

* String 클래스는 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없으나 StringBuffer 클래스는 변경이 가능하다

* 내부적으로 문자열 편집을 위한 버퍼(buffer)를 가지고 있으며, StringBuffer 인스턴스 생성 시 그 크기를 지정할 수 있다(변경 중 문자열이 크기를 초과하면 크기를 증가시키는 추가 작업이 수행된다)

#### StringBuffer 클래스

```java
public final class StringBuffer implements java.io.Serializable {
	private char[] value;
}

```

#### StringBuffer 생성자

```java
public StringBuffer(int length){
	value = new char[length]
 	share = flase;
}
public StringBuffer(){
	this(16)	// 버퍼의 크기 미 지정시 버퍼의 크기는 16이 된다
}
public StringBuffer(String str)
	this(str.length() + 16);	//지정한 문자열의 길이보다 16 더 크게 버퍼를 생성한다
	append(str)
}

```
#### StringBuffer 버퍼 증가 작업

* 배열의 길이는 변경될 수 없으므로 새로운 길이의 배열을 생성한 후 이전 배열의 값을 복사한다

```java
char newValue[] = new char[newCapacity];	// 새로운 길이(newCapacity)의 배열을 생성한다, newCapacity는 정수값이다
System.arraycopy(value, 0, newValue, 0, count); // count는 문자열의 길이
value = newValue; 	// 새로 생성된 배열의 주소를 참조변수 value에 저장
```

#### StringBuffer의 변경

* append()는 반환타입이 StringBuffer인데 자신의 주소를 반환한다.

```java
// 내용 변경
StringBuffer sb = new StringBuffer("abc"); // abc
sb.append("123") // abc123

// append는 자신의 주소를 반환, 즉 sb와 sb2는 같은 주소를 가리킨다
StringBuffer sb2 = sb.append("zz"); // sb 문자열 뒤에 "zz"를 추가
System.out.println(sb); // abc123zz
System.out.println(sb2); // abc123zz

// sb.append("123).append("zz") 로 축약 가능

```

#### StringBuffer의 비교

* String 클래스에서는 equals 메서드를 오버라이딩하여 문자열의 내용을 비교하도록 구현되어 있으나, StringBuffer 클래스는 오버라이딩 되어 있지 않다

* 반면 toString()은 오버라이딩이 되어 있어 StringBuffer 인스턴스에 toString()을 호출하면, 담고 있는 문자열을 String으로 반환한다

* 따라서 문자열을 비교하기 위해서는 toString()을 통해 String 인스턴스를 얻은 후, equals 메서드를 사용해서 비교해야한다

```java

    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer("abc");
        StringBuffer sb2 = new StringBuffer("abc");

        System.out.println("sb == sb2 ? " + (sb == sb2));
        System.out.println("sb.equals(sb2) ? " + sb.equals(sb2));

        String s = sb.toString();
        String s2 = sb2.toString();

        System.out.println("s.equals(s2) ? " + s.equals(s2));
    }
/*
Result:
sb == sb2 ? false
sb.equals(sb2) ? false
s.equals(s2) ? true
*/
```

******************************************************************************************************************************************************************************************

### 9.10) StringBuffer의 생성자 메서드

#### <StringBuffer의 메서드 Table>

|메서드|설명|
|:---:|:---:|
|StringBuffer()|16문자를 담을 수 있는 버퍼를 가진 StringBuffer 인스턴스를 생성한다|
|StringBuffer(int length)|지정된 개수의 문자를 담을 수 있는 버퍼를 가진 StringBuffer 인스턴스를 생성한다|
|StringBuffer(String str)|지정된 문자열 값(str)을 갖는 StringBuffer 인스턴스를 생성한다|
|StringBuffer append(boolean b) <br> StringBuffer append(char c) <br> StringBuffer append(char[] str) <br> StringBuffer append(double d) <br> StringBuffer append(float f) <br> StringBuffer append(int i) <br> StringBuffer append(long l) <br> StringBuffer append(Object obj) <br> StringBuffer append(String str)|매개변수로 입력된 값을 문자열로 변환하여 StringBuffer 인스턴스가 저장하고 있는 문자열의 뒤에 덧붙인다|
|int capacity()|StringBuffer 인스턴스의 버펄크기를 알려준다, length()는 버퍼에 담긴 문자열의 길이를 알려준다|
|char charAt(int index)|지정된 위치(index)에 있는 문자를 반환한다|
|StringBuffer delete(int start, int end)|시작위치(start)부터 끝 위치(end) 사이에 있는 문자를 제거한다, 단 끝 위치의 문자는 제외된다|
|StringBuffer deletedCharAt(int index)|지정된 위치(index)의 문자를 제거한다|
|StringBuffer insert(int pos, boolean b) <br> StringBuffer insert(int pos, char c) <br> StringBuffer insert(int pos, char[] str) <br> StringBuffer insert(int pos, double d) <br> StringBuffer insert(int pos, float f) <br> StringBuffer insert(int pos, int i) <br> StringBuffer insert(int pos, long l) <br> StringBuffer insert(int pos, Object obj) <br> StringBuffer insert(int pos, String str)|두 번째 매개변수로 받은 값을 문자열로 변환하여 지정된 위치(pos)에 추가한다, pos는 0부터 시작|
|int length()|StringBuffer 인스턴스에 저장되어 있는 문자열의 길이를 반환한다|
|StringBuffer replace(int start, int end, String str)|지정된 범위(start ~ end)의 문자들을 주어진 문자열로 바꾼다, end 위치의 문자는 범위에 포함되지 않는다|
|StringBuffer reverse()|StringBuffer인스턴스에 저장되어 있는 문자열의 순서를 거꾸로 나열한다|
|void setCharAt(int index, char ch)|지정된 위치의 문자를 주어진 문자(ch)로 바꾼다|
|void setLength(int newLength)|지정된 길이로 문자열의 길이를 변경한다, 기링를 늘리는 경우에 나머지 빈 공간을 null문자 '\u0000'로 채운다|
|String toString()|StringBuffer인스턴스의 문자열을 String으로 반환한다|
|String substring(int start) <br> String substring(int start, int end)|지정된 범위 내의 문자열을 String으로 뽑아서 반환한다, 시작 위치(strat)만 지정하면 시작 위치부터 문자열 끝까지 뽑아서 반환한다|

#### StringBuffer의 메서드 예시

```java

    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer("01");
        StringBuffer sb2 = sb.append(23);
        sb.append('4').append(56);

        StringBuffer sb3 = sb.append(78);
        sb.append(9.0);

        System.out.println("sb = " + sb);
        System.out.println("sb2 = " + sb2);
        System.out.println("sb3 = " + sb3);

        System.out.println("sb =" + sb.deleteCharAt(10));
        System.out.println("sb =" + sb.delete(3,6));
        System.out.println("sb =" + sb.insert(3,"abc"));
        System.out.println("sb =" + sb.replace(6, sb.length(), "END"));

        System.out.println("capacity = " + sb.capacity());
        System.out.println("length = " + sb.length());
    }

/*
Result:
sb = 0123456789.0
sb2 = 0123456789.0
sb3 = 0123456789.0
sb =01234567890
sb =01267890
sb =012abc67890
sb =012abcEND
capacity = 18
length = 9
*/

```

******************************************************************************************************************************************************************************************

### 9.11) StringBuilder

* StringBuffer는 멀티쓰레드에서 안전하도록 도익화되어 있다, 멀티 쓰레드로 자것ㅇ된 프로그램이 아닌 경우 StringBuffer의 동기화는 불필요하게 성능만 저하시킨다

* StringBuffer에서 쓰레드의 동기화만 뺀 StringBuilder가 있다, 완전히 동일한 기능을 하며 소스코드에서 StringBuffer 대신 StringBuilder를 사용하도록 변경하면 된다

******************************************************************************************************************************************************************************************

### 9.12) Math 클래스

* Math 클래스는 기본적인 수학계산에 유용한 메서드로 구성되어 있다

* Math 클래스의 생성자는 접근 제어자가 private이고, 클래스 내 인스턴스변수가 하나도 없다

* Math 클래스의 메서드는 모두 static이며, 상수 자연 로그의 밑(E)와 원주율(PI)만 정의되어 있다

#### <Math 메서드 Table>

|메서드|설명|
|:---:|:---:|
|static double abs(double a) <br> static float abs(float f) <br> static int abs(int f) <br> static long abs(long f)|주어진 값의 절대값을 반환한다|
|static double  ceil(double a)|주어진 값을 올림하여 반환한다|
|static double floor(double a|주어진 값을 버림하여 반환한다|
|static double max(double a, double b) <br> static float max(float a, float b) <br> static int max(int a, int b) <br> static long max(long a, long b)|주어진 두 값을 비교하여 큰 쪽을 반환한다|
|static double min(double a, double b) <br> static float min(float a, float b) <br> static int min(int a, int b) <br> static long min(long a, long b)|주어진 두 값을 비교하여 작은 쪽을 반환한다|
|static double random()|0.0 ~ 1.0 범위의 임의 double값을 반환한다(1.0은 범위에 포함되지 않는다)|
|static double rint(doube a)|주어진 double 값과 가장 가까운 정수 값을 double형으로 반환한다, 단 두 정수의 정가운데 있는 값(1.5, 2.5, 3.5 등)은 짝수를 반환한다|
|static long round(double a) <br> static long round(float a)|소수점 첫재자리에서 반올림한 정수값(long)을 반환한다, 두 정수의 정가운데 있는 값은 항상 큰 정수를 반환한다|

#### Math 메서드 예시

```java

import static java.lang.Math.*;

    public static void main(String[] args) {
        double val = 90.7552;
        System.out.println("round(" + val + ")=" + round(val)); // 반올림

        val *= 100;
        System.out.println("round(" + val + ")=" + round(val)); // 반올림

        System.out.println("round(" + val + ")/100=" + round(val)/100); // 반올림(정수)
        System.out.println("round(" + val + ")/100.0=" + round(val/100.0)); // 반올림(소수점 조정)
        System.out.println();

        System.out.println(ceil(1.1)); // 올림
        System.out.println(floor(1.5)); // 버림
        System.out.println(round(1.1)); // 반올림
        System.out.println(round(1.5)); // 반올림
        System.out.println(rint(1.5)); // 반올림
        System.out.println(round(-1.5)); // 반올림
        System.out.println(rint(-1.5)); // 반올림
        System.out.println(ceil(-1.5)); // 올림
        System.out.println(floor(-1.5)); // 버림
    }

/*
Result:
round(90.7552)=91
round(9075.52)=9076
round(9075.52)/100=90
round(9075.52)/100.0=91

2.0
1.0
1
2
2.0
-1
-2.0
-1.0
-2.0
*/

```

******************************************************************************************************************************************************************************************

### 9.13) 래퍼(wrapper) 클래스

* JAVA에서는 8 개의 기본형을 객체로 다루지 않는다

* 경우에 따라 기본형 변수도 객체로 다뤄야 해야 한다(매개변수로 객체를 요구, 기본형 값이 아닌 객체로 저장해야 할 때, 객체간의 비교가 필요할 때 등)

* 래퍼(wrapper)클래스를 통해 기본형 값을 객체로 다룰 수 있다

* 래퍼 클래스들은 모두 equals()가 오버라이딩 되어 있어 주소 값이 아닌 객체가 가지는 값을 비교한다

* 래퍼 클래스들은 모두 toString()도 오버라이딩 되어 있어 객체가 가지고 있는 값을 문자열로 변환하여 반환한다

* 이 외에도 래퍼 클래스들은 모두 MAX_VALUE, MIN_VALUE, SIZE, BYTES, TYPE 등의 static 상수를 공통적으로 가지고 있다

#### <래퍼(wrapper) 클래스 Table>

|기본형|래퍼클래스|생성자|
|:---:|:---:|:---:|
|boolean|Boolean|Boolean(boolean value) <br> Boolean(String s)|
|char|Character|Character(char value)|
|byte|Byte|Byte(byte value) <br> Byte(String s)|
|short|Short|Short(short value) <br> Shourt(String s)|
|int|Integer|Integer(int value) <br> Integer(Sting s)|
|long|Long|Long(long value) <br> Long(String s)|
|float|Float|Float(double value) <br> Float(float value) <br> Float(String s)|
|double|Double|Double(double value) <br> Double(String s)|

#### 래퍼(wrapper) 클래스 예시

```java

    public static void main(String[] args) {
        Integer i = new Integer(100);
        Integer i2 = new Integer(100);

        System.out.println("i==i2 ? " + (i == i2));
        System.out.println("i.equals(i2) ? " + i.equals(i2));
        System.out.println("i.compareTo(i2) = " + i.compareTo(i2));
        System.out.println("i.toString() = " + i.toString(i2));

        System.out.println("MAX_VALUE = " + Integer.MAX_VALUE);
        System.out.println("MIN_VALUE = " + Integer.MIN_VALUE);
        System.out.println("SIZE = " + Integer.SIZE);
        System.out.println("BYTES = " + Integer.BYTES);
        System.out.println("TYPE = " + Integer.TYPE);
    }

/*
Result:
i==i2 ? false
i.equals(i2) ? true
i.compareTo(i2) = 0
i.toString() = 100
MAX_VALUE = 2147483647
MIN_VALUE = -2147483648
SIZE = 32
BYTES = 4
TYPE = int
*/

```
******************************************************************************************************************************************************************************************

### 9.14) Number클래스

* Number 클래스는 추상 클래스로 내부적으로 숫자를 멤버변수로 갖는 래퍼 클래스들의 조상이다

* 그 외 BigInteger (long으로 다룰 수 없는 큰 범위의 정수), BigDecimal (double로 다룰 수 없는 큰 범위의 소수점수)가 있다

#### Number클래스
```java
public abstract class Number implements java.io.Serializable {
	public abstract int intValue();
	public abstract long longValue();
	public abstract float floatValue();
	public abstract double doubleValue();

	public byte byteValue() {
		return(byte)intValue;
	}
	public Short shortValue() {
		return(short)intValue;
	}

```

******************************************************************************************************************************************************************************************

### 9.14) 문자열을 숫자로 변환하기

* '타입.parse타입(String s)' 형식의 메서드는 반환값이 기본형이고 '타입.valueOf()' 메서드는 반환값이 래퍼 클래스 타입이다

* 문자열이 10진수가 아닌 다른 진법(radix)의 숫자일 때도 변환이 가능하다

#### <문자열 숫자 변환 Table>

|문자열 → 기본형|기본형 → 문자열|
|:---:|:---:|
|byte b = Byte.parseByte("100"); <br> short s = short.parseShort("100"); <br> int i = integer.parseInt("100); <br> long l = Long.parseLong("100"); <br> float f = Float.parseFloat("3.14"); <br> double d = Double.parseDouble("3.14")| byte b = Byte.valueOf("100"); <br> short s = short.valueOf("100"); <br> int i = integer.valueOf("100); <br> long l = Long.valueOf("100"); <br> float f = Float.valueOf("3.14"); <br> double d = Double.valueOf("3.14")|

#### 문자열 숫자 변환 진법 지정

```java

static int parseInt(String s, int radix) 
static Integer valueOf(String s, int radix)
// 문자열 s를 radix진법으로 인식한다

```

#### 문자열을 숫자로 변환하기 예시

```java
    public static void main(String[] args) {
        int i = new Integer("100").intValue();
        int i2 = Integer.parseInt("100");
        int i3 = Integer.valueOf("100");

        int i4 = Integer.parseInt("100", 2);
        int i5 = Integer.parseInt("100", 8);
        int i6 = Integer.parseInt("100", 16);
        int i7 = Integer.parseInt("FF", 16);
//      int i8 = Integer.parseInt("FF")    // 진법 누락으로 NumberFormatException 발생

        Integer i9 = Integer.valueOf("100", 2);
        Integer i10 = Integer.valueOf("100", 8);
        Integer i11 = Integer.valueOf("100", 16);
        Integer i12 = Integer.valueOf("FF", 16);
//      Integer i13 = Integer.valueOf("FF") // 진법 누락으로 NumberFormatException 발생

        System.out.println(i);
        System.out.println(i2);
        System.out.println(i3);
        System.out.println("100(2) -> " + i4);
        System.out.println("100(8) -> " + i5);
        System.out.println("100(16) -> " + i6);
        System.out.println("FF(16) -> " + i7);

        System.out.println("100(2) -> " + i9);
        System.out.println("100(8) -> " + i10);
        System.out.println("100(16) -> " + i11);
        System.out.println("FF(16) -> " + i12);
    }
/*
Result:
100
100
100
100(2) -> 4
100(8) -> 64
100(16) -> 256
FF(16) -> 25
100(2) -> 4
100(8) -> 64
100(16) -> 256
FF(16) -> 255

*/

```

******************************************************************************************************************************************************************************************

### 9.15) 오토박싱 & 언박싱

* 기존의 JAVA는 기본형과 참조형 간의 연산이 불가능 했으나(래퍼 클래스로 기본형 객체를 만들어서 진행해야 했다), 컴파일러가 자동으로 변환하는 코드를 넣게 되어 가능하게 되었다

* 내부적으로 객체 배열을 가지고 있는 Vector 클래스 혹은 ArrayList 클래스에 기본형 값을 저장해야 할 때나 형변환이 필요할 때도 컴파일러가 자동적으로 코드를 추가해준다

* 기본형 값을 래퍼클래스의 객체로 자동 변환 해주는 것을 '오토박싱(autoboxing)', 반대로 변환하는 것을 '언박싱(unboxing)'이라고 한다

#### 오토박싱 & 언박싱

```java
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(10);	// 오토박싱, 10 > new Integer(10)

int value = list.get(0); 	// 언박싱, new Integer(10) > 10

```
#### 오토박싱 & 언박싱 예시

```java

    public static void main(String[] args) {
        int i = 10;

        // 기본형을 참조형으로 형변환(형변환 생략 가능)
        Integer intg = (Integer)i; // Integer intg = Integer.valueOf(i);
        Object obj = (Object)i; // Object obj = (Object)Integer.valueOf(i);

        Long lng = 100L; // Long lng = new Long(100L)

        int i2 = intg + 10; // 참조형과 기본형간 연산 가능
        long l = intg + lng; // 참조형 간 덧셈 가능

        Integer intg2 = new Integer(20);
        int i3 = (int)intg2; // 참조형을 기본형으로 형변환도 가능(형변환 생략 가능)

        Integer intg3 = intg2 + i3;

        System.out.println("i = " + i);
        System.out.println("intg = " + intg);
        System.out.println("obj = " + obj);
        System.out.println("lng = " + lng);
        System.out.println("intg + 10 = " + i2);
        System.out.println("intg + ing = " + l);
        System.out.println("intg2 = " + intg2);
        System.out.println("i3 = " + i3);
        System.out.println("intg2 + i3 = " + intg3);


/*
Result:
i = 10
intg = 10
obj = 10
lng = 100
intg + 10 = 20
intg + ing = 110
intg2 = 20
i3 = 20
intg2 + i3 = 40
*/

```

******************************************************************************************************************************************************************************************

## 10) 날짜와 시간

### 10.1) Calendar 클래스

* Calendar 클래스는 추상클래스이므로 직접 객체를 생성할 수 없으며, 메서드틀 통해서 구현된 클래스의 인스터스를 얻어야 한다

* getInstance()를 통해서 얻은 인스턴스는 현재 시스템의 날짜와 시간에 대한 정보를 담고 있다

* 날짜와 시간을 원하는 값으로 변경하려면 set메서드를 사용하면 된다
 
#### Calendar 클래스
```java
Calendar cal = new Calendar(); // 에러 > 추상클래스는 인스턴스를 생성할 수 없다
Calendar cal = Calendar.getInstance(); // OK > getInstance()메서드는 Calendar 클래스를 구현한 클래스의 인스턴스를 반환한다
```

#### Calendar 클래스
```java
void set(int year, int month, int date, int hourOfday, int minute, int second)
```


#### Calendar 클래스 예시
```java

    public static void main(String[] args) {

        Calendar today = Calendar.getInstance();
        System.out.println("이 해의 년도: " + today.get(Calendar.YEAR));
        System.out.println("월(0~11, 0:1월): " + today.get(Calendar.MONTH));
        System.out.println("이 해의 몇 째 주: " + +today.get(Calendar.WEEK_OF_MONTH));
        System.out.println("이 달의 몇 째 주: " + today.get(Calendar.WEEK_OF_YEAR));

        System.out.println("이 달의 몇 일: " + today.get(Calendar.DATE));
        System.out.println("이 달의 몇 일: " + today.get(Calendar.DAY_OF_MONTH));
        System.out.println("이 해의 몇 일: " + today.get(Calendar.DAY_OF_YEAR));
        System.out.println("요일(1~7, 1:일요일): " + today.get(Calendar.DAY_OF_WEEK));
        System.out.println("이 달의 몇 째 요일: " + today.get(Calendar.DAY_OF_WEEK_IN_MONTH));

        System.out.println("오전_오후(0:오전, 1:오후): " + today.get(Calendar.AM_PM));
        System.out.println("시간(0~11): " + today.get(Calendar.HOUR));
        System.out.println("시간(0~23): " + today.get(Calendar.HOUR_OF_DAY));
        System.out.println("분(0~59): " + today.get(Calendar.MINUTE));
        System.out.println("초(0~59): " + today.get(Calendar.SECOND));
        System.out.println("1000분의 1초(0~999): " + today.get(Calendar.MILLISECOND));
        System.out.println("TimeZone(-12 ~ +12): " + today.get(Calendar.ZONE_OFFSET / (60 * 60 * 1000)));
        System.out.println("이 달의 마지막 날: " + today.getActualMaximum(Calendar.DATE));

/*
Result:
이 해의 년도: 2024
월(0~11, 0:1월): 4
이 해의 몇 째 주: 3
이 달의 몇 째 주: 20
이 달의 몇 일: 16
이 달의 몇 일: 16
이 해의 몇 일: 137
요일(1~7, 1:일요일): 5
이 달의 몇 째 요일: 3
오전_오후(0:오전, 1:오후): 0
시간(0~11): 0
시간(0~23): 0
분(0~59): 2
초(0~59): 55
1000분의 1초(0~999): 803
TimeZone(-12 ~ +12): 1
이 달의 마지막 날: 31

*/

    }
}
```
#### Calendar 클래스 예시2
```java
    public static void main(String[] args) {
        final String[] DAY_OF_WEEK = {"", "일", "월", "화", "수", "목", "금", "토"};

        Calendar date1 = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();

        // month의 경우 0부터 시작하기 때문에 4월인 경우, 3으로 지정해야한다
        date1.set(2019, 3, 29); // 2019년 4월 29일로 설정
        System.out.println("date1은 " + toString(date1) + DAY_OF_WEEK[date1.get(Calendar.DAY_OF_WEEK)] + "요일이고, ");
        System.out.println("오늘(date2)은 " + toString(date2) + DAY_OF_WEEK[date2.get(Calendar.DAY_OF_WEEK)] + "요일입니다.");

        //두 날짜간의 차이를 얻으려면, getTimeInMillis() 천분의 일초 단위로 변환해야한다
        long difference = (date2.getTimeInMillis() - date1.getTimeInMillis())/1000;
        System.out.println("그 날(date1)부터 지금(date2)까지 " + difference + "초가 지났습니다");
        System.out.println("일(day)로 계산하면 " + difference / (24 * 60 * 60) + "일입니다."); // 1일 = 24 * 60 * 60
    }
    public static String toString(Calendar date) {
        return date.get(Calendar.YEAR)+"년 " + (date.get(Calendar.MONTH)+1) + "월 " + date.get(Calendar.DATE) + "일 ";
    }
/*
Result:
date1은 2019년 4월 29일 월요일이고, 
오늘(date2)은 2024년 5월 16일 목요일입니다.
그 날(date1)부터 지금(date2)까지 159321600초가 지났습니다
일(day)로 계산하면 1844일입니다.
*/
```

#### Calendar 예시 3
```java

    public static void main(String[] args) {
        final int[] TIME_UNIT = {3600, 60, 1};
        final String[] TIME_UNIT_NAME = {"시간", "분", "초"};

        Calendar time1 = Calendar.getInstance();
        Calendar time2 = Calendar.getInstance();

        time1.set(Calendar.HOUR_OF_DAY, 10);
        time1.set(Calendar.MINUTE, 20);
        time1.set(Calendar.SECOND, 20);

        time2.set(Calendar.HOUR_OF_DAY, 20);
        time2.set(Calendar.MINUTE, 30);
        time2.set(Calendar.SECOND, 10);

        System.out.println("time1: " + time1.get(Calendar.HOUR_OF_DAY) + "시 " + time1.get(Calendar.MINUTE) + "분 "
                + time1.get(Calendar.SECOND) + "초");
        System.out.println("time2: " + time2.get(Calendar.HOUR_OF_DAY) + "시 " + time2.get(Calendar.MINUTE) + "분 "
                + time2.get(Calendar.SECOND) + "초");

        long difference = Math.abs(time2.getTimeInMillis() - time1.getTimeInMillis())/1000;
        System.out.println("time1과 time2의 차이는 " + difference + "초 입니다.");

        String tmp = "";
        for (int i = 0; i < TIME_UNIT.length; i++ ) {
            tmp += difference / TIME_UNIT[i] + TIME_UNIT_NAME[i];
            difference %= TIME_UNIT[i];
        }
        System.out.println("시분초로 변환하면 " + tmp + "입니다.");
    }

/*
Result:
time1: 10시 20분 20초
time2: 20시 30분 10초
time1과 time2의 차이는 36590초 입니다.
시분초로 변환하면 10시간9분50초입니다.
*/
```
#### Calendar 예시4
```java

    public static void main(String[] args) {
        Calendar date = Calendar.getInstance();
        date.set(2019, 7, 31);

        System.out.println(toString(date));
        System.out.println("= 1일 후 =");
        date.add(Calendar.DATE, 1);
        System.out.println(toString(date));

        System.out.println(" = 6달 전 =");
        date.add(Calendar.MONTH, -6);
        System.out.println(toString(date));

        System.out.println(" = 31일 후(roll) =");
        date.roll(Calendar.DATE, 31);
        System.out.println(toString(date));

        System.out.println(" = 31일 후(add) =");
        date.add(Calendar.DATE, 31);
        System.out.println(toString(date));

    }

    public static String toString(Calendar date) {
        return date.get(Calendar.YEAR) + "년 " + (date.get(Calendar.MONTH)+1) + "월 " + date.get(Calendar.DATE) + "일";
    }

/*
Result:
2019년 8월 31일
= 1일 후 =
2019년 9월 1일
 = 6달 전 =
2019년 3월 1일
 = 31일 후(roll) =
2019년 3월 1일
 = 31일 후(add) =
2019년 4월 1일
*/
```

